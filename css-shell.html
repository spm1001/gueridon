<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>CSS Shell Test</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="stylesheet" href="/style.css">
<style>
  /* === Shell-only overrides ===
     style.css carries the full layout (body-scroll, sticky input,
     field-sizing, CSS-drawn buttons, placeholder text). This block only adds
     things the shell needs that production doesn't. */

  /* Show + and / buttons without JS (production shows via .visible class) */
  .btn-slash, .btn-file {
    display: flex !important;
  }
</style>
</head>
<body>

  <!-- Messages area â€” body-scroll layout -->
  <div class="messages" id="messages">
    <div class="msg-system">CSS shell â€” layout test bed with live diagnostics</div>
    <pre id="diag" style="font-family:var(--mono);font-size:0.72rem;color:var(--text-dim);line-height:1.8;padding:12px;background:var(--surface);border-radius:8px;white-space:pre-wrap;"></pre>

    <!-- Dummy messages â€” varied lengths to stress-test layout -->
    <div class="msg-user">Can you help me refactor this module?</div>
    <div class="msg-assistant"><p>Sure.</p></div>
    <div class="msg-user">The scroll is on the document body now, right?</div>
    <div class="msg-assistant"><p>Yes. <code>.messages</code> has no <code>overflow-y</code> â€” content flows into the document. Safari's Full Page screenshot captures <code>document.documentElement.scrollHeight</code>, so the page must be taller than the viewport for the "Full Page" tab to appear.</p></div>
    <div class="msg-user">What about the input area?</div>
    <div class="msg-assistant"><p>Sticky.</p></div>
    <div class="msg-user">Explain sticky positioning on iOS</div>
    <div class="msg-assistant"><p><code>position: sticky; bottom: 0</code> keeps the input pinned at the viewport bottom while the document scrolls. <code>will-change: transform</code> promotes it to its own compositor layer, preventing flicker during iOS keyboard animation.</p><p>The alternative â€” <code>position: fixed</code> â€” is positioned relative to the visual viewport on iOS, which lies about its height in standalone mode (793px vs 852px). Sticky participates in document flow, sidestepping the issue entirely.</p><p>One emergent behaviour: at the very top of a long conversation, the sticky input disappears because the content hasn't scrolled past it yet. This is actually desirable â€” it gives you the full viewport for reading.</p></div>
    <div class="msg-user">How does auto-follow work?</div>
    <div class="msg-assistant"><p>JS checks whether you're near the bottom (within 150px) before each render. If yes, <code>scrollTo</code> after the DOM update. If not, leave you alone.</p></div>
    <div class="msg-user">Why not scroll-snap?</div>
    <div class="msg-assistant"><p>Tried it. Fought iOS keyboard animation â€” caused the input to flicker on every keypress.</p></div>
    <div class="msg-user">Show me a code example</div>
    <div class="msg-assistant"><p>Here's the layout model:</p><pre><code>html {
  overflow-x: hidden;
}
body {
  min-height: 100dvh;
  display: flex;
  flex-direction: column;
}
.messages {
  flex: 1 0 auto;
}
.input-area {
  position: sticky;
  bottom: 0;
  will-change: transform;
}</code></pre><p>Three rules do most of the work. The rest is safe-area padding.</p></div>
    <div class="msg-user">Nice</div>
    <div class="msg-assistant"><p>Thanks.</p></div>
    <div class="msg-user">Tell me about the flex layout in more detail</div>
    <div class="msg-assistant"><p><code>flex: 1 0 auto</code> means grow to fill, never shrink, content-sized basis.</p><p>This matters because <code>flex: 1</code> (shorthand for <code>1 1 0</code>) sets the basis to zero â€” meaning messages <em>can collapse to zero height</em>. The full shorthand prevents that.</p><p>Combined with <code>.messages &gt; * { flex-shrink: 0 }</code> (the 2px collapse fix), every child maintains its natural height. Without that rule, <code>overflow: hidden</code> on flex children changes <code>min-height</code> from <code>min-content</code> to <code>0</code> per CSS spec.</p></div>
    <div class="msg-user">How does field-sizing: content work?</div>
    <div class="msg-assistant"><p>The textarea auto-grows. <code>max-height: 40dvh</code> caps it, then <code>overflow-y: auto</code> adds a scrollbar.</p></div>
    <div class="msg-user">What should I check in this test?</div>
    <div class="msg-assistant"><p>Four things:</p><ol><li>Input bar stays at bottom while scrolling</li><li>Safari screenshot shows "Full Page" tab</li><li>Keyboard open/close keeps input visible â€” <strong>this is the main experiment</strong></li><li>Type in the textarea to verify field-sizing auto-grow</li></ol><p>Tap send to start the streaming simulator.</p></div>
    <div class="msg-user">I've been noticing some visual jank in the input area â€” the gap between the textarea and the button bar feels uneven, and the + and / buttons don't look quite right. Can you take a look at style.css and the css-shell and figure out what's going on?</div>
    <div class="msg-assistant"><p>On it.</p></div>
    <div class="msg-user">What did you find?</div>
    <div class="msg-assistant"><p>Three issues:</p><ul><li><strong>Gap mismatch:</strong> <code>.input-area</code> had <code>gap: 6px</code> but <code>.btn-bar</code> had <code>gap: 8px</code>. Bumped both to 8px for uniform rhythm.</li><li><strong>Button symbols:</strong> The <code>+</code> and <code>/</code> were text characters using font metrics â€” slightly off-centre depending on the font. Replaced with CSS pseudo-elements: absolute-positioned bars with <code>currentColor</code>, geometrically centred. No font dependency.</li><li><strong>Placeholder text:</strong> Empty folder label and context percentage were blank. Added <code>::before</code> pseudo-content: "GuÃ©ridon" and "0%" in <code>var(--text-dim)</code>.</li></ul></div>
    <div class="snap-anchor"></div>
  </div>

  <script>
  // Diagnostic readouts â€” updates live on resize/viewport change
  let keyboardOpen = false;
  function measure() {
    const d = document.getElementById('diag');
    const vv = window.visualViewport;
    const standalone = window.matchMedia('(display-mode: standalone)').matches;
    const bodyCS = getComputedStyle(document.body);
    const htmlCS = getComputedStyle(document.documentElement);

    const docScrollH = document.documentElement.scrollHeight;
    const overflow = docScrollH > window.innerHeight;
    const scrollGap = docScrollH - window.scrollY - window.innerHeight;
    d.textContent = [
      `mode:        ${standalone ? 'STANDALONE' : 'browser'}`,
      `screen.h:    ${screen.height}px`,
      `innerHeight: ${window.innerHeight}px`,
      `vv.height:   ${vv ? vv.height + 'px' : 'n/a'}`,
      `keyboard:    ${keyboardOpen ? 'OPEN' : 'closed'}`,
      ``,
      `body.h (computed): ${bodyCS.height}`,
      `doc.scrollH:       ${docScrollH}px`,
      `window.scrollY:    ${Math.round(window.scrollY)}px`,
      `scrollGap:         ${Math.round(scrollGap)}px ${scrollGap < 150 ? '(near bottom)' : ''}`,
      `OVERFLOW:          ${overflow ? 'YES âœ“' : 'NO âœ— (need more content)'}`,
      ``,
      `html overflow:     ${htmlCS.overflow || htmlCS.overflowY || 'auto'}`,
      `messages.h:        ${getComputedStyle(document.querySelector('.messages')).height}`,
      `input sticky:      ${getComputedStyle(document.querySelector('.input-area')).position}`,
    ].join('\n');
  }

  measure();
  window.addEventListener('resize', measure);
  window.addEventListener('scroll', measure);
  if (window.visualViewport) {
    const refHeight = window.visualViewport.height;
    window.visualViewport.addEventListener('resize', () => {
      keyboardOpen = window.visualViewport.height < refHeight - 100;
      document.querySelector('.input-area').classList.toggle('keyboard-open', keyboardOpen);
      measure();
    });
    window.visualViewport.addEventListener('scroll', measure);
  }
  setTimeout(measure, 500);

  </script>

  <div class="input-area">
    <textarea class="input-field" placeholder="Message Claude..." rows="1" autocomplete="off" autocorrect="off" spellcheck="false"></textarea>
    <div class="staged-deposits" id="stagedDeposits"></div>
    <div class="btn-bar">
      <button class="btn-circle btn-file" aria-label="Attach" id="fileBtn">+</button>
      <button class="btn-circle btn-slash" aria-label="Commands" id="slashBtn">/</button>
      <button class="btn-lozenge folder" id="folderBtn"><span class="label" id="project"></span></button>
      <button class="btn-lozenge context" id="contextBtn"><span class="pct" id="contextPct"></span><span class="push-denied" id="pushDenied" title="Notifications blocked">ðŸ”‡</span></button>
      <button class="btn-circle btn-send" aria-label="Send" id="sendBtn">&#x2191;</button>
    </div>
  </div>

  <!-- Streaming simulator â€” tap send to toggle. Appends DOM nodes only, no JS scroll. -->
  <script>
  let streaming = false;
  let streamCount = 0;
  const sendBtn = document.getElementById('sendBtn');
  const messages = document.getElementById('messages');
  const anchor = messages.querySelector('.snap-anchor');

  sendBtn.addEventListener('click', () => {
    streaming = !streaming;
    sendBtn.style.background = streaming ? 'var(--red)' : '';
    if (streaming) appendStream();
  });

  function appendStream() {
    if (!streaming) return;
    streamCount++;

    const div = document.createElement('div');
    div.className = streamCount % 2 ? 'msg-assistant' : 'msg-user';
    div.innerHTML = streamCount % 2
      ? `<p>Streamed response #${streamCount} â€” does the page follow? CSS only, no JS scroll.</p>`
      : `Simulated message #${streamCount}`;
    messages.insertBefore(div, anchor);

    setTimeout(appendStream, 800);
  }
  </script>

</body>
</html>
