{"id": "gdn-cejaba", "type": "outcome", "title": "Access Claude Code from mobile with full harness", "brief": {"why": "Claude Code is terminal-only. Full experience (MCPs, CLAUDE.md, skills, tools) needs to be accessible from phone/tablet on home network, using MAX subscription instead of API billing.", "what": "1. ClaudeCodeAgent adapter implementing pi-web-ui Agent interface 2. JSONL event mapper (CC events → pi AgentEvents) 3. Node.js bridge server (WebSocket ↔ stdio) 4. Web app shell with pi-web-ui components 5. Directory picker for session launch 6. Tool execution viewer 7. AskUserQuestion mobile rendering", "done": "Can open browser on phone, pick a project directory, chat with Claude Code, see streaming responses and tool executions, tap AskUserQuestion options, and resume sessions after disconnect"}, "status": "open", "order": 1, "created_at": "2026-02-08T10:31:43Z", "created_by": "spm1001"}
{"id": "gdn-sohadi", "type": "action", "title": "Scaffold project and wire up pi-web-ui", "brief": {"why": "Need working build pipeline before writing adapter code. pi-web-ui packages are on npm, need Vite bundler with Tailwind.", "what": "1. npm init with type:module 2. Install pi-web-ui, pi-agent-core, pi-ai, mini-lit, lit 3. Vite config with Tailwind plugin 4. Minimal index.html + main.ts loading AgentInterface 5. Verify components render", "done": "npm run dev serves a page with pi-web-ui chat interface visible (even if non-functional)"}, "status": "done", "parent": "gdn-cejaba", "order": 1, "created_at": "2026-02-08T10:31:56Z", "created_by": "spm1001", "waiting_for": null, "tactical": {"steps": ["npm init with type:module", "Install pi-web-ui, pi-agent-core, pi-ai, mini-lit, lit", "Vite config with Tailwind plugin", "Minimal index.html + main.ts loading AgentInterface", "Verify components render"], "current": 5}, "done_at": "2026-02-08T11:10:17Z"}
{"id": "gdn-cawuge", "type": "action", "title": "Context fuel gauge and compaction visibility", "brief": {"why": "Mobile sessions run long without visibility into context usage. Users need a glanceable indicator (not a command to type) and notification when compaction happens, so they can manage session length.", "what": "1. Track usage from CC result events in adapter (input_tokens / contextWindow = percent) 2. Build context gauge component with color thresholds (>70% yellow, >90% red) 3. Detect compaction (input_tokens drop between turns) and surface as notification 4. Use hybrid estimation from pi-mono: last known usage + chars/4 for trailing messages", "done": "Context percentage visible in mobile UI, updates after each turn, yellow/red thresholds work, compaction events shown as notifications"}, "status": "done", "parent": "gdn-cejaba", "order": 2, "created_at": "2026-02-08T10:31:56Z", "created_by": "spm1001", "waiting_for": null, "done_at": "2026-02-08T17:57:19Z"}
{"id": "gdn-lenuge", "type": "action", "title": "Build ClaudeCodeAgent adapter", "brief": {"why": "The adapter is the core translation layer between CC stream-json events and pi-web-ui's Agent interface. All context about the Agent contract and event mapping is warm in this session.", "what": "1. Subclass Agent from pi-agent-core 2. Override prompt() to send via transport (WebSocket later) 3. Build CC event handler that translates stream-json events to pi AgentEvents and state changes 4. Wire into main.ts replacing stub Agent 5. Verify ChatPanel still renders with adapter", "done": "ClaudeCodeAgent class exists, handles all CC event types from event-mapping.md, ChatPanel renders with it (non-functional until bridge exists)"}, "status": "done", "parent": "gdn-cejaba", "order": 3, "created_at": "2026-02-08T11:22:57Z", "created_by": "spm1001", "waiting_for": null, "tactical": {"steps": ["Subclass Agent from pi-agent-core", "Override prompt() to send via transport (WebSocket later)", "Build CC event handler that translates stream-json events to pi AgentEvents and state changes", "Wire into main.ts replacing stub Agent", "Verify ChatPanel still renders with adapter"], "current": 5}, "done_at": "2026-02-08T11:25:39Z"}
{"id": "gdn-jiwize", "type": "action", "title": "Build bridge server", "brief": {"why": "The bridge server is what makes the adapter functional — it spawns and manages claude -p processes, pipes stdin/stdout as JSONL, and exposes a WebSocket endpoint for the browser.", "what": "1. Node.js WebSocket server (ws package) 2. Process-per-session: spawn claude -p with required flags on WS connect 3. Pipe WS messages to CC stdin as stream-json input format 4. Parse CC stdout JSONL and forward events over WS 5. Session management: idle timeout, kill, --resume on reconnect 6. Handle process lifecycle (exit, crash, restart)", "done": "Bridge server runs, browser can connect via WS, typing in ChatPanel sends to CC and streamed response renders in the UI"}, "status": "done", "parent": "gdn-cejaba", "order": 4, "created_at": "2026-02-08T17:54:50Z", "created_by": "spm1001", "waiting_for": null, "tactical": {"steps": ["Node.js WebSocket server (ws package)", "Process-per-session: spawn claude -p with required flags on WS connect", "Pipe WS messages to CC stdin as stream-json input format", "Parse CC stdout JSONL and forward events over WS", "Session management: idle timeout, kill, --resume on reconnect", "Handle process lifecycle (exit, crash, restart)"], "current": 6}, "done_at": "2026-02-08T18:17:48Z"}
{"id": "gdn-lihibi", "type": "action", "title": "Build WebSocket transport for browser", "brief": {"why": "The adapter has a CCTransport interface but no implementation. The browser needs a WebSocket client that connects to the bridge and satisfies CCTransport.", "what": "1. Implement CCTransport over WebSocket 2. Auto-reconnect with exponential backoff 3. Wire into ClaudeCodeAgent.connectTransport() in main.ts 4. Connection status indicator in UI", "done": "Browser connects to bridge on page load, messages flow both directions, reconnects after disconnect"}, "status": "done", "parent": "gdn-cejaba", "order": 5, "created_at": "2026-02-08T17:55:00Z", "created_by": "spm1001", "waiting_for": null, "tactical": {"steps": ["Implement CCTransport over WebSocket", "Auto-reconnect with exponential backoff", "Wire into ClaudeCodeAgent.connectTransport() in main.ts", "Connection status indicator in UI"], "current": 4}, "done_at": "2026-02-08T18:41:59Z"}
{"id": "gdn-togeca", "type": "action", "title": "Context fuel gauge component", "brief": {"why": "Mobile sessions run long without visibility. The adapter already tracks context usage from CC result events — need to surface it as a glanceable UI element.", "what": "1. Thin progress bar component using context % from adapter 2. Color thresholds: green default, yellow >70%, red >90% 3. Compaction detection (input_tokens drop) with notification 4. Position near input area for mobile visibility", "done": "Context bar visible in UI, updates after each turn, color changes at thresholds, compaction notified"}, "status": "done", "parent": "gdn-cejaba", "order": 6, "created_at": "2026-02-08T17:55:10Z", "created_by": "spm1001", "waiting_for": null, "tactical": {"steps": ["Thin progress bar component using context % from adapter", "Color thresholds: green default, yellow >70%, red >90%", "Compaction detection (input_tokens drop) with notification", "Position near input area for mobile visibility"], "current": 4}, "done_at": "2026-02-08T19:55:05Z"}
{"id": "gdn-rehona", "type": "action", "title": "Adapter unit tests from verified JSONL", "brief": {"why": "The adapter translates CC stream-json events to pi AgentEvents. We have verified JSONL schemas in docs/empirical-verification.md — feeding them through handleCCEvent() and asserting output catches regressions.", "what": "1. Test framework (vitest) 2. Feed verified JSONL sequences through handleCCEvent 3. Assert resulting pi AgentEvents and state changes 4. Cover: text response, tool use, thinking blocks, error, abort", "done": "Tests pass, cover all event types from empirical-verification.md"}, "status": "done", "parent": "gdn-vevoca", "order": 5, "created_at": "2026-02-08T17:57:48Z", "created_by": "spm1001", "waiting_for": null, "tactical": {"steps": ["Test framework (vitest)", "Feed verified JSONL sequences through handleCCEvent", "Assert resulting pi AgentEvents and state changes", "Cover: text response, tool use, thinking blocks, error, abort"], "current": 4}, "done_at": "2026-02-09T09:31:47Z"}
{"id": "gdn-guruno", "type": "action", "title": "AskUserQuestion mobile interception", "brief": {"why": "In -p mode, AskUserQuestion fires as a tool_use event with full question/options structure BEFORE the error result. Bridge should intercept this, render as tappable buttons on mobile, and send the user's answer as the next message.", "what": "1. Bridge detects tool_use with name AskUserQuestion 2. Forward question/options to browser as a special event 3. Render as tappable button UI (not in chat flow) 4. User tap sends answer as next prompt 5. Coach CC via --append-system-prompt that AskUserQuestion errors are expected", "done": "AskUserQuestion renders as tappable buttons on mobile, user's selection flows back as a message"}, "status": "done", "parent": "gdn-cejaba", "order": 7, "created_at": "2026-02-08T17:57:57Z", "created_by": "spm1001", "waiting_for": null, "tactical": {"steps": ["Bridge detects tool_use with name AskUserQuestion", "Forward question/options to browser as a special event", "Render as tappable button UI (not in chat flow)", "User tap sends answer as next prompt", "Coach CC via --append-system-prompt that AskUserQuestion errors are expected"], "current": 5}, "done_at": "2026-02-08T19:24:07Z"}
{"id": "gdn-celuko", "type": "action", "title": "Resolve artifacts tool mismatch", "brief": {"why": "ChatPanel.setAgent() injects an artifacts tool via toolsFactory. CC doesn't know about this tool — it uses Write for artifacts. The artifacts panel will show UI that doesn't map to CC's capabilities.", "what": "1. Investigate: does the artifacts tool cause errors or just unused UI? 2. Options: suppress artifacts tool in setAgent config, OR map CC Write of .html/.svg to pi artifact events 3. Decide and implement", "done": "No misleading artifacts UI, or artifacts tool maps correctly to CC Write-based artifacts"}, "status": "open", "parent": "gdn-cejaba", "order": 8, "created_at": "2026-02-08T17:58:07Z", "created_by": "spm1001", "waiting_for": null}
{"id": "gdn-gukivo", "type": "action", "title": "Investigate image input via CC stdin content arrays", "brief": {"why": "ChatPanel lets users attach images but adapter strips them to text-only. CC stdin format uses string content — unknown whether content arrays with image blocks work.", "what": "1. Test CC stdin with content array format: {type:'user', message:{role:'user', content:[{type:'text',text:'...'},{type:'image',source:{...}}]}} 2. If it works, update bridge to pass attachments through 3. If not, disable attachment button in ChatPanel or show a clear error", "done": "Know whether CC accepts image content arrays via stdin. Either images flow end-to-end or attachment UI is disabled with explanation."}, "status": "open", "parent": "gdn-cejaba", "order": 9, "created_at": "2026-02-08T19:04:28Z", "created_by": "spm1001", "waiting_for": null}
{"id": "gdn-hatiho", "type": "outcome", "title": "Session lifecycle on mobile — folder identity, closure rituals, handoffs", "brief": {"why": "Mobile sessions currently have no identity (random UUIDs), no closure ritual, and no handoff. When a session dies the next Claude starts blind. Desktop rituals (/open, /close, arc, handoffs) need mobile equivalents so sessions survive the context boundary.", "what": "1. Bridge session registry + folder list endpoint 2. Folder chooser UI with search 3. Deterministic session IDs from folder path 4. Handoff/paused state display in chooser 5. Resume flow (paused → unfreeze, closed → fresh with handoff) 6. New folder creation with fun names 7. Mobile /close trigger 8. Closure nudge from fuel gauge", "done": "User can pick a folder, resume where they left off, get nudged to close when context is full, and the next session in that folder picks up the handoff"}, "status": "open", "order": 2, "created_at": "2026-02-08T19:50:33Z", "created_by": "spm1001", "waiting_for": null}
{"id": "gdn-pahawu", "type": "action", "title": "Code-split heavy deps for mobile data", "brief": {"why": "Bundle is 4.7MB (1.2MB gzip) — fine on WiFi but painful on mobile data. KaTeX, PDF.js, highlight.js are only needed when CC sends math/docs/code.", "what": "1. Audit pi-web-ui imports for lazy-loadable chunks 2. Dynamic import() for KaTeX, PDF.js, highlight.js on first use 3. Consider service worker for offline cache", "done": "First load under 500KB gzip on fresh cache. Heavy deps load on demand."}, "status": "open", "parent": "gdn-cejaba", "order": 10, "created_at": "2026-02-08T21:35:36Z", "created_by": "spm1001", "waiting_for": null}
{"id": "gdn-zovogo", "type": "outcome", "title": "Bridge folder awareness — scan, enrich, connect", "brief": {"why": "The folder chooser needs to know: which folders exist, which have active/paused/closed sessions, and what each was working on. The bridge is the only actor with filesystem access. No registry — derive all state from CC session files + handoffs + runtime.", "what": "Folder scan module, bridge lobby mode, folder protocol (listFolders/connectFolder), multi-WS broadcast, transport API", "done": "Bridge returns enriched folder list. Multiple tabs can connect to different folders simultaneously. All state derived from filesystem, no registry file."}, "status": "done", "parent": null, "order": 3, "created_at": "2026-02-08T22:12:47Z", "created_by": "spm1001", "done_at": "2026-02-09T07:20:51Z"}
{"id": "gdn-sinefu", "type": "action", "title": "Folder chooser UI with search and session states", "brief": {"why": "User needs to pick a folder before chatting. With tens of repos, a flat list isn't enough — needs search/filter. Each folder shows its session state (active/paused/closed/fresh) so the user knows what they're getting into.", "what": "1. Full-screen chooser shown before chat (replaces empty chat on first load) 2. Scrollable list of folders from bridge API 3. Search/filter input at top (filters as you type) 4. Visual states: green dot (active), amber dot (paused + time ago), handoff purpose line (closed), plain (fresh) 5. 'New folder' option at top with fun auto-generated name 6. Selecting a folder transitions to chat view with CWD in gauge", "done": "Can scroll through 30+ folders, search narrows list instantly, all four states render distinctly, selecting transitions to chat."}, "status": "done", "parent": "gdn-hatiho", "order": 1, "created_at": "2026-02-08T22:12:57Z", "created_by": "spm1001", "waiting_for": null, "tactical": {"steps": ["Full-screen chooser shown before chat (replaces empty chat on first load)", "Scrollable list of folders from bridge API", "Search/filter input at top (filters as you type)", "Visual states: green dot (active), amber dot (paused + time ago), handoff purpose line (closed), plain (fresh)", "'New folder' option at top with fun auto-generated name", "Selecting a folder transitions to chat view with CWD in gauge"], "current": 6}, "done_at": "2026-02-09T07:34:12Z"}
{"id": "gdn-neperu", "type": "action", "title": "Deterministic session IDs and resume flow", "brief": {"why": "Currently session IDs are random UUIDs — picking a folder can't find its session. Folder path must deterministically produce a session ID so resume works. The three resume paths (active/paused/closed) each behave differently.", "what": "1. Derive session ID from folder path (hash or slugify — must be stable and CC-compatible) 2. Active: switch to running process (instant) 3. Paused: spawn CC with --resume --session-id in that folder (8s unfreeze) 4. Closed: spawn fresh CC with new session-id, bridge sends handoff content as context 5. Fresh: spawn fresh CC, no handoff 6. Bridge passes cwd to spawn() so CC reads correct CLAUDE.md/arc", "done": "Picking any folder in any state leads to the right CC session. Resume unfreezes correctly. Fresh sessions start in the right directory."}, "status": "open", "parent": "gdn-hatiho", "order": 2, "created_at": "2026-02-08T22:13:07Z", "created_by": "spm1001", "waiting_for": null}
{"id": "gdn-cahato", "type": "action", "title": "New folder creation with fun names", "brief": {"why": "Sometimes you start fresh — new project, new experiment. 'New folder' creates ~/Repos/<name>, git inits it, and starts a session there. Auto-naming removes friction and adds character.", "what": "1. Bridge endpoint to create folder: mkdir ~/Repos/<name> && git init 2. Name generator — alliterative or thematic (guéridon/table-service riff? Docker-style adjective-noun?) 3. Show generated name before confirming 4. After creation, transition to chat in new folder", "done": "Tapping 'New folder' shows a generated name, creates the repo, and drops into a fresh session."}, "status": "open", "parent": "gdn-hatiho", "order": 3, "created_at": "2026-02-08T22:13:16Z", "created_by": "spm1001", "waiting_for": null}
{"id": "gdn-cofuci", "type": "action", "title": "Mobile close trigger and closure nudge", "brief": {"why": "Desktop /close is typed. Mobile needs a tap-friendly equivalent. The fuel gauge already tracks context — when it hits amber/red, nudge the user to wrap up rather than letting the session die ungracefully.", "what": "1. UI affordance to trigger /close (button in nav? long-press on gauge? slide-up menu?) 2. Fuel gauge amber/red bands trigger a gentle 'consider wrapping up' prompt 3. /close runs inside CC session (it's a skill — CC handles reflection, handoff, commit) 4. On handoff written, bridge updates registry status to closed 5. Option to return to folder chooser after close", "done": "User can trigger close from UI. Gauge nudges at thresholds. Handoff written and visible in chooser next time."}, "status": "open", "parent": "gdn-hatiho", "order": 4, "created_at": "2026-02-08T22:13:27Z", "created_by": "spm1001", "waiting_for": null}
{"id": "gdn-laneve", "type": "action", "title": "Verify double-render fix visually", "brief": {"why": "Patched AgentInterface to clear streaming container on message_end (not just agent_end) to fix duplicate message display. Committed but never tested live.", "what": "1. Start bridge + dev server 2. Send a multi-turn conversation 3. Watch for duplicate messages during turn transitions 4. Verify streaming container clears when message completes", "done": "No visible duplicate messages during streaming→complete transition across 3+ turns."}, "status": "done", "parent": "gdn-cejaba", "order": 11, "created_at": "2026-02-08T22:19:14Z", "created_by": "spm1001", "waiting_for": null, "tactical": {"steps": ["Start bridge + dev server", "Send a multi-turn conversation", "Watch for duplicate messages during turn transitions", "Verify streaming container clears when message completes"], "current": 4}, "done_at": "2026-02-08T22:45:12Z"}
{"id": "gdn-murimo", "type": "action", "title": "Trim desktop chrome for mobile — keep useful controls", "brief": {"why": "Pi-web-ui's button row has desktop-oriented controls (thinking toggle, model selector, attachment button, Anthropic logo) that eat vertical space on mobile. Some are useful to wire up (attachment for image input?), model selector is irrelevant (CC handles model selection server-side).", "what": "1. Audit which controls are useful on mobile vs pure desktop cruft 2. Remove or hide model selector (CC-controlled, not user-facing) 3. Evaluate thinking toggle — could map to CC's thinking config? 4. Keep attachment button if image input is viable (gdn-gukivo) 5. Consider what replaces them — session name? folder indicator?", "done": "Button row shows only mobile-relevant controls. No wasted vertical space."}, "status": "open", "parent": "gdn-cejaba", "order": 12, "created_at": "2026-02-08T22:19:25Z", "created_by": "spm1001", "waiting_for": null}
{"id": "gdn-fuhola", "type": "action", "title": "Folder scan module with filesystem state derivation", "brief": {"why": "The bridge needs to enumerate ~/Repos/ folders and determine each one's session state (active/paused/closed/fresh) without maintaining a registry. CC already stores session files at ~/.claude/projects/<encoded>/ and handoffs at ~/.claude/handoffs/<encoded>/.", "what": "1. Create server/folders.ts with encodePath(), getLatestSession(), getLatestHandoff(), scanFolders() 2. Scan ~/Repos/ dirs, stat each for type 3. For each: check CC projects dir for .jsonl files (paused), check handoffs for .md files (closed) 4. State logic: active from runtime map, paused wins over closed, fresh if neither 5. Sort: active > paused > closed > fresh 6. Test standalone with a script that logs the enriched list", "done": "scanFolders() returns correct state for guéridon (paused), a fresh repo (fresh), and folders with handoffs (closed). Standalone test script verifies."}, "status": "done", "parent": "gdn-zovogo", "order": 1, "created_at": "2026-02-09T06:15:11Z", "created_by": "spm1001", "waiting_for": null, "tactical": {"steps": ["Create server/folders.ts with encodePath(), getLatestSession(), getLatestHandoff(), scanFolders()", "Scan ~/Repos/ dirs, stat each for type", "For each: check CC projects dir for .jsonl files (paused), check handoffs for .md files (closed)", "State logic: active from runtime map, paused wins over closed, fresh if neither", "Sort: active > paused > closed > fresh", "Test standalone with a script that logs the enriched list"], "current": 6}, "done_at": "2026-02-09T06:17:17Z"}
{"id": "gdn-nasahe", "type": "action", "title": "Bridge lobby mode and folder protocol", "brief": {"why": "Currently every WS connection immediately creates a session. The folder chooser needs a pre-session 'lobby' where the browser can list folders and pick one before any CC process is spawned.", "what": "1. Add folder field to Session interface 2. WS connects without ?session= enters lobby mode (no session created) 3. Handle listFolders message — call scanFolders(), return folderList response 4. Handle connectFolder message — create/resume session for chosen folder, send connected with sessionId 5. Reject prompt/abort in lobby mode with error 6. Existing ?session= path unchanged for backwards compat", "done": "WS can connect, send listFolders, get enriched list back, send connectFolder, get session. Prompt before connectFolder returns error. Old ?session= flow still works."}, "status": "done", "parent": "gdn-zovogo", "order": 2, "created_at": "2026-02-09T06:15:19Z", "created_by": "spm1001", "waiting_for": null, "tactical": {"steps": ["Add folder field to Session interface", "WS connects without ?session= enters lobby mode (no session created)", "Handle listFolders message — call scanFolders(), return folderList response", "Handle connectFolder message — create/resume session for chosen folder, send connected with sessionId", "Reject prompt/abort in lobby mode with error", "Existing ?session= path unchanged for backwards compat"], "current": 6}, "done_at": "2026-02-09T06:51:15Z"}
{"id": "gdn-figina", "type": "action", "title": "Multi-WS sessions with broadcast", "brief": {"why": "Multiple browser tabs can connect to the same folder. They should share a CC process and all receive events. Currently Session.ws is a single WebSocket.", "what": "1. Change Session.ws from WebSocket|null to Set<WebSocket> 2. Add reverse map ws→sessionId for disconnect lookups 3. All sendToClient calls become broadcast to Set 4. Idle timer starts when Set empties (all tabs gone) 5. Ping/pong remains per-WebSocket 6. connectFolder checks activeByFolder — if session exists, join it", "done": "Two WS connections to same folder share one CC process. Both receive streamed events. Disconnecting one doesn't kill the session. Disconnecting both starts idle timer."}, "status": "done", "parent": "gdn-zovogo", "order": 3, "created_at": "2026-02-09T06:15:26Z", "created_by": "spm1001", "waiting_for": null, "tactical": {"steps": ["Change Session.ws from WebSocket|null to Set<WebSocket>", "Add reverse map ws→sessionId for disconnect lookups", "All sendToClient calls become broadcast to Set", "Idle timer starts when Set empties (all tabs gone)", "Ping/pong remains per-WebSocket", "connectFolder checks activeByFolder — if session exists, join it"], "current": 6}, "done_at": "2026-02-09T07:17:19Z"}
{"id": "gdn-likira", "type": "action", "title": "Transport folder API and lobby handling", "brief": {"why": "The browser-side WSTransport needs methods to request the folder list and connect to a folder. It also needs to handle the lobby state where no session exists yet.", "what": "1. Add listFolders() and connectFolder(path) methods to WSTransport 2. Add onFolderList callback in options 3. Handle folderList message type in handleMessage 4. Handle connected with null sessionId (lobby mode) — don't fire onSessionId until connectFolder completes 5. Update docs/bridge-protocol.md with new message types and lobby flow", "done": "Transport can request folder list and receive it via callback. connectFolder triggers session establishment. Protocol docs updated."}, "status": "done", "parent": "gdn-zovogo", "order": 4, "created_at": "2026-02-09T06:15:34Z", "created_by": "spm1001", "waiting_for": null, "tactical": {"steps": ["Add listFolders() and connectFolder(path) methods to WSTransport", "Add onFolderList callback in options", "Handle folderList message type in handleMessage", "Handle connected with null sessionId (lobby mode) — don't fire onSessionId until connectFolder completes", "Update docs/bridge-protocol.md with new message types and lobby flow"], "current": 5}, "done_at": "2026-02-09T07:19:52Z"}
{"id": "gdn-hemute", "type": "action", "title": "Integration test for listFolders protocol", "brief": {"why": "The folder list API (listFolders/folderList) needs an integration test that verifies the WS protocol end-to-end. Currently test-bridge.ts covers prompt/abort but nothing folder-related.", "what": "1. Add listFolders test to scripts/test-bridge.ts (or new script) 2. Connect WS without ?session= (lobby mode) 3. Send listFolders, verify folderList response shape 4. Verify known folders appear with correct states 5. Send connectFolder, verify connected response with sessionId", "done": "Test script passes: connects, lists folders, gets enriched list back, connects to a folder. Can run against live bridge."}, "status": "done", "parent": "gdn-zovogo", "order": 5, "created_at": "2026-02-09T06:22:37Z", "created_by": "spm1001", "waiting_for": null, "done_at": "2026-02-09T07:20:15Z"}
{"id": "gdn-vevoca", "type": "outcome", "title": "Automated test coverage for guéridon", "brief": {"why": "Zero test framework, zero automated tests. The adapter (most protocol-sensitive code) has no tests. As bridge refactor and folder chooser add complexity, regressions will compound silently.", "what": "Vitest framework setup, adapter unit tests (from verified JSONL fixtures), folder scan tests (mocked fs), transport tests (mock WebSocket), gauge tests, eventually bridge SessionManager extraction", "done": "npm test runs vitest. Adapter and folder scan have >80% coverage. CI-ready (no manual steps, no running servers needed)."}, "status": "done", "order": 4, "created_at": "2026-02-09T06:38:30Z", "created_by": "spm1001", "done_at": "2026-02-09T09:55:27Z"}
{"id": "gdn-womabe", "type": "action", "title": "Set up vitest framework and npm test scripts", "brief": {"why": "No test framework exists. Need vitest (reuses vite.config.ts aliases and esbuild target), npm scripts, and basic config before any tests can be written.", "what": "1. npm install -D vitest 2. Add test and test:watch scripts to package.json 3. Verify vitest inherits vite.config.ts (pi-web-ui alias, es2020 target) 4. Write one trivial test (encodePath) to confirm setup works 5. Add jsdom devDep for future browser-side tests", "done": "npm test runs and passes. vitest picks up vite.config.ts aliases. One test exists and passes."}, "status": "done", "parent": "gdn-vevoca", "order": 1, "created_at": "2026-02-09T06:38:40Z", "created_by": "spm1001", "waiting_for": null, "tactical": {"steps": ["npm install -D vitest", "Add test and test:watch scripts to package.json", "Verify vitest inherits vite.config.ts (pi-web-ui alias, es2020 target)", "Write one trivial test (encodePath) to confirm setup works", "Add jsdom devDep for future browser-side tests"], "current": 5}, "done_at": "2026-02-09T09:20:14Z"}
{"id": "gdn-muloda", "type": "action", "title": "Folder scan unit tests with mocked fs", "brief": {"why": "server/folders.ts has pure functions and mockable fs calls — high value, low effort. The regex-based handoff parsing is fragile and untested against edge cases.", "what": "1. Create server/folders.test.ts 2. Test encodePath edge cases (slashes, dots, spaces, root) 3. Test getLatestSession with vi.mock('node:fs/promises') — ENOENT, empty dir, picks newest, ignores non-jsonl 4. Test getLatestHandoff — well-formed, malformed, missing dir 5. Test scanFolders — state derivation for all four states, sort order, hidden dirs skipped, activeProcesses map", "done": "All tests pass. Covers encodePath, getLatestSession, getLatestHandoff, scanFolders with mocked filesystem."}, "status": "done", "parent": "gdn-vevoca", "order": 2, "created_at": "2026-02-09T06:38:47Z", "created_by": "spm1001", "waiting_for": null, "tactical": {"steps": ["Create server/folders.test.ts", "Test encodePath edge cases (slashes, dots, spaces, root)", "Test getLatestSession with vi.mock('node:fs/promises') — ENOENT, empty dir, picks newest, ignores non-jsonl", "Test getLatestHandoff — well-formed, malformed, missing dir", "Test scanFolders — state derivation for all four states, sort order, hidden dirs skipped, activeProcesses map"], "current": 5}, "done_at": "2026-02-09T09:24:47Z"}
{"id": "gdn-wisupe", "type": "action", "title": "Transport unit tests with mock WebSocket", "brief": {"why": "ws-transport.ts handles protocol discrimination, reconnect backoff, and prompt timeout — all testable with mock WebSocket and fake timers. Medium effort but catches real bugs (e.g. processExit not synthesizing result event).", "what": "1. Create src/ws-transport.test.ts 2. Stub global WebSocket with controllable mock 3. Test message dispatch (bridge vs cc source) 4. Test reconnect backoff (1s, 2s, 4s... 30s cap) with fake timers 5. Test prompt timeout (fires after 10s, clears on promptReceived) 6. Test processExit → synthetic result event", "done": "All tests pass with fake timers and mock WebSocket. No real connections needed."}, "status": "done", "parent": "gdn-vevoca", "order": 3, "created_at": "2026-02-09T06:38:56Z", "created_by": "spm1001", "waiting_for": null, "tactical": {"steps": ["Create src/ws-transport.test.ts", "Stub global WebSocket with controllable mock", "Test message dispatch (bridge vs cc source)", "Test reconnect backoff (1s, 2s, 4s... 30s cap) with fake timers", "Test prompt timeout (fires after 10s, clears on promptReceived)", "Test processExit → synthetic result event"], "current": 6}, "done_at": "2026-02-09T09:41:13Z"}
{"id": "gdn-taleta", "type": "action", "title": "Context gauge unit tests", "brief": {"why": "context-gauge.ts has clean public API (update, setCwd, notifyCompaction, renderStats) and colour threshold logic that's never been verified.", "what": "1. Create src/context-gauge.test.ts with jsdom environment 2. Test colour thresholds (green >20%, amber 10-20%, red <10%) 3. Test CWD shortening (full path → folder name) 4. Test notifyCompaction toast timing with fake timers 5. Test renderStats returns valid Lit templates", "done": "All tests pass. Colour bands verified. Compaction toast appears and auto-dismisses."}, "status": "done", "parent": "gdn-vevoca", "order": 4, "created_at": "2026-02-09T06:39:04Z", "created_by": "spm1001", "waiting_for": null, "done_at": "2026-02-09T09:41:27Z"}
{"id": "gdn-mazeni", "type": "action", "title": "Folder selector dialog replaces model chooser", "brief": {"why": "pi-web-ui orchestration layer (ChatPanel, AgentInterface, MessageEditor) is full of abstractions we don't need (model selector, thinking level, cost tracking) and blocks input area customisation. Own the orchestration, consume the rendering (MessageList, StreamingMessageContainer) — the seam is clean (12 props + 1 imperative method).", "what": "1. Write GueridonInterface skeleton — Lit component rendering message-list + streaming-container + basic textarea, event translation loop, replace ChatPanel in main.ts 2. Build custom input bar — image upload placeholder, folder button with CWD display (truncated), inline context gauge %, send/abort button 3. Write FolderSelector dialog — centered modal with search and state dots, reuse folder-chooser rendering 4. Wire folder button to dialog to transport, auto-open on first load 5. Move connection status below chat input 6. Remove old code — ChatPanel/AppStorage setup, context-gauge.ts, full-screen folder-chooser.ts", "done": "GueridonInterface renders messages correctly. Custom input bar has folder button + gauge + send. Folder dialog opens from button and auto-opens on first load. Connection status at bottom. No ChatPanel/AgentInterface/MessageEditor dependency. No as-any casts for customStats."}, "status": "done", "parent": "gdn-hatiho", "order": 5, "created_at": "2026-02-09T07:54:25Z", "created_by": "spm1001", "waiting_for": null, "tactical": {"steps": ["Write GueridonInterface skeleton — Lit component rendering message-list + streaming-container + basic textarea, event translation loop, replace ChatPanel in main.ts", "Build custom input bar — image upload placeholder, folder button with CWD display (truncated), inline context gauge %, send/abort button", "Write FolderSelector dialog — centered modal with search and state dots, reuse folder-chooser rendering", "Wire folder button to dialog to transport, auto-open on first load", "Move connection status below chat input", "Remove old code — ChatPanel/AppStorage setup, context-gauge.ts, full-screen folder-chooser.ts"], "current": 6}, "done_at": "2026-02-09T08:38:20Z"}
{"id": "gdn-kurato", "type": "action", "title": "State derivation unit test — closed wins over paused", "brief": {"why": "The closed-wins-over-paused logic and resume guard are regression-prone. Someone reading the code might think 'paused should win' without understanding session files persist forever. The resume bug (resuming closed sessions) was found by the user in live use.", "what": "1. Mock fs for folders with: both session+handoff (closed), session only (paused), handoff only (closed), neither (fresh) 2. Assert state derivation correctness 3. Test connectFolder: closed folder gets fresh UUID, paused folder reuses session ID", "done": "Tests cover all state derivation paths and the resume guard. Regression on closed-wins-over-paused would fail a test."}, "status": "done", "parent": "gdn-vevoca", "order": 6, "created_at": "2026-02-09T08:03:34Z", "created_by": "spm1001", "waiting_for": null, "done_at": "2026-02-09T09:43:56Z"}
{"id": "gdn-zibaha", "type": "action", "title": "Folder dialog opens then immediately closes", "brief": {"why": "Dialog flashes then disappears on page load. onSessionId fires right after onFolderList, closing the dialog before user can interact. CWD shows itv-linkedin-analytics without user selection — something is auto-connecting.", "what": "1. Check browser console (traces already added in main.ts) 2. Trace why onSessionId fires in lobby mode 3. Check if bridge sends connected without connectFolder 4. Fix the race condition", "done": "Folder dialog stays open until user selects. No auto-close on page load."}, "status": "open", "parent": "gdn-hatiho", "order": 6, "created_at": "2026-02-09T09:04:31Z", "created_by": "spm1001", "waiting_for": null}
{"id": "gdn-dacega", "type": "action", "title": "Build test catches transitive dependency failures", "brief": {"why": "npm run build would have caught the @smithy import failure from session 3. Currently no build-time test exists — transitive dependency issues only surface when someone manually runs a production build.", "what": "1. Add a vitest test that runs npm run build and asserts exit code 0 2. Consider adding to a pre-commit hook or CI", "done": "npm test includes a build check. Transitive import failures are caught automatically."}, "status": "done", "parent": "gdn-vevoca", "order": 7, "created_at": "2026-02-09T09:44:44Z", "created_by": "spm1001", "waiting_for": null, "tactical": {"steps": ["Add a vitest test that runs npm run build and asserts exit code 0", "Consider adding to a pre-commit hook or CI"], "current": 2}, "done_at": "2026-02-09T09:55:09Z"}
{"id": "gdn-jimozo", "type": "action", "title": "End-to-end adapter sequence test", "brief": {"why": "Individual event handlers are tested but the full composition isn't. A prompt→stream→tool_use→tool_result→text_response→result sequence through handleCCEvent would catch ordering bugs and state leaks between phases.", "what": "1. Create a test that feeds a complete multi-turn CC event sequence 2. Assert intermediate state at each phase (isStreaming, pendingToolCalls, messages array) 3. Cover: text-only turn, tool-use turn, AskUserQuestion turn", "done": "At least one full-sequence test exercises the adapter from prompt to result, verifying state at each transition."}, "status": "done", "parent": "gdn-vevoca", "order": 8, "created_at": "2026-02-09T09:44:52Z", "created_by": "spm1001", "waiting_for": null, "tactical": {"steps": ["Create a test that feeds a complete multi-turn CC event sequence", "Assert intermediate state at each phase (isStreaming, pendingToolCalls, messages array)", "Cover: text-only turn, tool-use turn, AskUserQuestion turn"], "current": 3}, "done_at": "2026-02-09T09:55:18Z"}
