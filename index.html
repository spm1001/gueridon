<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>GuÃ©ridon</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/icon-192.svg" type="image/svg+xml">
<meta name="theme-color" content="#1a1a1a">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="stylesheet" href="/style.css">
</head>
<body>

  <div class="switcher-backdrop" id="switcherBackdrop"></div>
  <div class="switcher" id="switcher">
    <div class="switcher-handle"></div>
    <div class="switcher-header">
      <span class="status-connection" id="switcherConnectionDot"></span>
      <input class="switcher-search" id="switcherSearch" type="text" placeholder="Filter sessionsâ€¦">
      <button class="switcher-close" id="switcherClose" aria-label="Close">&#x2715;</button>
    </div>
    <div class="switcher-list" id="switcherList"></div>
  </div>

  <div class="ask-backdrop" id="askBackdrop"></div>
  <div class="ask-sheet" id="askSheet">
    <div class="ask-handle"></div>
    <div id="askContent"></div>
  </div>

  <div class="drop-overlay" id="dropOverlay">
    <div class="drop-overlay-label">Drop files here</div>
  </div>

  <div class="messages" id="messages"></div>


  <div class="slash-sheet-overlay" id="slashSheet">
    <div class="slash-sheet">
      <div class="slash-sheet-handle"></div>
      <div class="slash-sheet-header">
        <div class="slash-sheet-title">Commands</div>
        <button class="slash-close" aria-label="Close">&#x2715;</button>
      </div>
      <input class="slash-search" id="slashSearch" type="text" placeholder="Filter commandsâ€¦">
      <div id="slashList"></div>
    </div>
  </div>

  <div class="input-area">
    <textarea class="input-field" placeholder="Message Claude..." rows="1" autocomplete="off" autocorrect="off" spellcheck="false"></textarea>
    <div class="staged-deposits" id="stagedDeposits"></div>
    <div class="btn-bar">
      <button class="btn-circle btn-file" aria-label="Attach" id="fileBtn">+</button>
      <button class="btn-circle btn-slash" aria-label="Commands" id="slashBtn">/</button>
      <button class="btn-lozenge folder" id="folderBtn"><span class="label" id="project"></span></button>
      <button class="btn-lozenge context" id="contextBtn"><span class="pct" id="contextPct"></span><span class="push-denied" id="pushDenied" title="Notifications blocked">ðŸ”‡</span></button>
      <button class="btn-circle btn-send" aria-label="Send" id="sendBtn">&#x2191;</button>
    </div>
  </div>

<script>
// Early error handler â€” catches script load failures and syntax errors that
// occur BEFORE the inline script's own error reporting sets up. Without this,
// a broken module chain produces a silently dead page (gdn-lemega).
window.__gdnErrors = [];
window.addEventListener('error', function(e) {
  window.__gdnErrors.push(e.message + (e.filename ? ' @ ' + e.filename + ':' + e.lineno : ''));
  var d = document.getElementById('__gdnErrorBanner');
  if (!d) {
    d = document.createElement('pre');
    d.id = '__gdnErrorBanner';
    d.style.cssText = 'position:fixed;top:0;left:0;right:0;z-index:99999;background:#c33;color:white;padding:12px 16px;font-size:13px;white-space:pre-wrap;max-height:40vh;overflow:auto;margin:0;font-family:monospace;';
    (document.body || document.documentElement).appendChild(d);
  }
  d.textContent = 'GuÃ©ridon JS error:\n' + window.__gdnErrors.join('\n');
}, true);
</script>
<script src="/marked.js"></script>
<script src="/render-utils.js"></script>
<script src="/render-chips.js"></script>
<script src="/render-messages.js"></script>
<script src="/render-chrome.js"></script>
<script src="/render-overlays.js"></script>
<script>
// === Client error reporting ===
// Captures unhandled errors and promise rejections, sends to bridge.
// Fire-and-forget â€” never blocks or throws.
{
  const reported = new Set();
  window.reportError = reportError;
  function reportError(message, stack) {
    const key = message + (stack || '');
    if (reported.has(key)) return;
    reported.add(key);
    setTimeout(() => reported.delete(key), 5000); // dedup window
    try {
      fetch('/client-error', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message, stack, userAgent: navigator.userAgent, url: location.href }),
      }).catch(() => {}); // swallow fetch failures
    } catch { /* swallow */ }
  }
  window.addEventListener('error', (e) => reportError(e.message, e.error?.stack));
  window.addEventListener('unhandledrejection', (e) => reportError(String(e.reason), e.reason?.stack));
}

let cachedState = null;
let switcherOpen = false;
let switcherExpandedFolder = null; // folder name currently expanded in switcher

// === Mode detection ===
const params = new URLSearchParams(location.search);
let bridgeUrl = params.get('bridge'); // Explicit bridge URL: ?bridge=http://kube:3001

// === iOS keyboard detection ===
// Body-scroll layout: no height-setting needed (body grows with content,
// the iOS viewport lie doesn't matter). Only toggle keyboard-open class
// for safe-area padding adjustments in standalone mode.
{
  if (window.visualViewport) {
    const inputArea = document.querySelector('.input-area');
    const refHeight = window.visualViewport.height;
    window.visualViewport.addEventListener('resize', () => {
      const keyboardOpen = window.visualViewport.height < refHeight - 100;
      inputArea.classList.toggle('keyboard-open', keyboardOpen);
    });
  }
}

// === Push notifications ===
let swRegistration = null;
let swReady = null;
let pushPermissionGranted = false;
let lastPushTag = null; // dedup: skip replay of same idle state on SSE reconnect
document.addEventListener('visibilitychange', () => {
  if (!document.hidden) lastPushTag = null; // page visible â€” allow next notification
});

// Register service worker immediately (needed for push + PWA install)
if ('serviceWorker' in navigator) {
  swReady = navigator.serviceWorker.register('/sw.js').then(
    (reg) => { swRegistration = reg; return reg; },
    (e) => { console.warn('[push] SW registration failed:', e); return null; },
  );
  // Listen for notification click deep-links from service worker
  navigator.serviceWorker.addEventListener('message', (ev) => {
    if (ev.data?.type === 'notificationClick' && ev.data.folder) {
      location.hash = ev.data.folder;
    }
  });
} else {
  swReady = Promise.resolve(null);
}

/** Request notification permission. Must be called from user gesture. */
async function pushRequestPermission() {
  if (!('Notification' in window)) return false;
  if (Notification.permission === 'granted') { pushPermissionGranted = true; return true; }
  if (Notification.permission === 'denied') {
    document.getElementById('pushDenied').classList.add('visible');
    return false;
  }
  const result = await Notification.requestPermission();
  pushPermissionGranted = result === 'granted';
  if (!pushPermissionGranted) {
    document.getElementById('pushDenied').classList.add('visible');
  }
  return pushPermissionGranted;
}

// Push denied indicator: tap shows instructions
document.getElementById('pushDenied').addEventListener('click', (e) => {
  e.stopPropagation();
  alert('Notifications are blocked.\n\nTo re-enable:\niOS: Settings â†’ Notifications â†’ Safari\nAndroid: Site settings â†’ Notifications');
});

/** Subscribe to push via bridge. Call after hello provides VAPID key. */
async function pushSubscribe(vapidPublicKey) {
  await swReady;
  if (!swRegistration || !vapidPublicKey || !('PushManager' in window)) return;
  try {
    let sub = await swRegistration.pushManager.getSubscription();
    if (!sub) {
      const padding = '='.repeat((4 - (vapidPublicKey.length % 4)) % 4);
      const b64 = (vapidPublicKey + padding).replace(/-/g, '+').replace(/_/g, '/');
      const raw = atob(b64);
      const key = new Uint8Array(raw.length);
      for (let i = 0; i < raw.length; i++) key[i] = raw.charCodeAt(i);
      sub = await swRegistration.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: key });
    }
    // POST subscription to bridge
    if (bridgeUrl) {
      const subHeaders = { 'Content-Type': 'application/json' };
      if (ssePushToken) subHeaders['X-Push-Token'] = ssePushToken;
      await fetch(`${bridgeUrl}/push/subscribe`, {
        method: 'POST',
        headers: subHeaders,
        body: JSON.stringify(sub.toJSON()),
      });
      console.log('[push] Subscription sent to bridge');
    }
  } catch (e) {
    console.warn('[push] Subscription failed:', e);
  }
}

/** Show local notification (when page is unfocused and SW available). */
function pushNotify(body, opts = {}) {
  if (document.hasFocus()) return;
  if (!pushPermissionGranted && (typeof Notification === 'undefined' || Notification.permission !== 'granted')) return;
  const tag = opts.tag || 'gueridon-default';
  // Dedup: SSE reconnects replay the same idle state snapshot, which re-triggers
  // this function. Skip if we already notified for this tag. Cleared when status
  // transitions to 'working' (new turn) or when the page regains focus.
  if (tag === lastPushTag) return;
  lastPushTag = tag;
  const title = 'GuÃ©ridon';
  if (swRegistration) {
    swRegistration.showNotification(title, {
      body,
      icon: '/icon-192.svg',
      badge: '/icon-192.svg',
      tag,
      renotify: true,
      vibrate: opts.vibrate || [200],
      data: { folder: opts.folder || '' },
    });
  } else {
    new Notification(title, { body, icon: '/icon-192.svg', tag });
  }
}

// === SSE bridge client ===
let sseSource = null;
let sseClientId = 'bb-' + Date.now().toString(36) + Math.random().toString(36).slice(2, 6);
let sseCurrentFolder = null; // folder name we're connected to
let ssePushToken = null;     // bridge-issued token for push subscribe/unsubscribe auth (gdn-ricocu)
let sseWatchdog = null;
const SSE_WATCHDOG_MS = 65_000; // 60s silence = dead (pings every 30s + margin)

// Live state â€” shared between SSE and WS modes
let liveState = {
  session: {},
  messages: [],
  connection: 'disconnected',
  status: 'idle',
  switcher: null,
  _activity: null,
};

function sseConnect() {
  if (!bridgeUrl) return;
  if (sseSource) { sseSource.close(); sseSource = null; }

  const url = `${bridgeUrl}/events?clientId=${encodeURIComponent(sseClientId)}`;
  sseSource = new EventSource(url);

  sseSource.addEventListener('hello', (ev) => {
    const data = JSON.parse(ev.data);
    if (data.version !== 1) {
      console.error('[bb] protocol version mismatch, reloading');
      location.reload();
      return;
    }
    liveState.connection = 'connected';
    sseResetWatchdog();
    sseRender();

    // Store bridge-issued push token for subscribe/unsubscribe auth (gdn-ricocu)
    ssePushToken = data.pushToken || null;

    // Subscribe to push if bridge provides VAPID key
    if (data.vapidPublicKey) {
      pushSubscribe(data.vapidPublicKey);
    }

    // Re-establish session from hash or previous state.
    // Clear stale messages â€” the POST /session response sends a fresh state snapshot.
    // Without this, deltas arriving between reconnect and state snapshot accumulate
    // on top of old messages, causing visual duplication.
    if (sseCurrentFolder) {
      // Always clear stale messages when we have an active folder â€”
      // both auto-reconnect (Last-Event-ID) and watchdog reconnect (fresh
      // EventSource) need a clean slate before the state snapshot arrives.
      liveState.messages = [];
      ssePostSession(sseCurrentFolder);
    } else if (location.hash.length > 1) {
      ssePostSession(location.hash.slice(1));
    }
  });

  sseSource.addEventListener('folders', (ev) => {
    const data = JSON.parse(ev.data);
    sseResetWatchdog();
    handleSSEFolders(data.folders || []);
  });

  sseSource.addEventListener('state', (ev) => {
    const data = JSON.parse(ev.data);
    sseResetWatchdog();
    // Discard events for wrong folder (data.folder is the routing key; data.session is the session object)
    if (sseCurrentFolder && data.folder && data.folder !== sseCurrentFolder) return;
    handleSSEState(data);
  });

  sseSource.addEventListener('delta', (ev) => {
    const data = JSON.parse(ev.data);
    sseResetWatchdog();
    if (sseCurrentFolder && data.folder && data.folder !== sseCurrentFolder) return;
    handleSSEDelta(data);
  });

  sseSource.addEventListener('ping', () => {
    sseResetWatchdog();
  });

  sseSource.onerror = () => {
    liveState.connection = 'disconnected';
    liveState._activity = null;
    sseRender();
    // EventSource auto-reconnects â€” no manual retry needed
  };

  sseSource.onopen = () => {
    // Fires on initial connect and each reconnect
    sseResetWatchdog();
  };
}

function sseResetWatchdog() {
  if (sseWatchdog) clearTimeout(sseWatchdog);
  sseWatchdog = setTimeout(() => {
    console.log('[bb] SSE watchdog: no events for 65s, reconnecting');
    if (sseSource) { sseSource.close(); sseSource = null; }
    liveState.connection = 'disconnected';
    sseRender();
    sseConnect();
  }, SSE_WATCHDOG_MS);
}

function mapFolderState(state) {
  if (state === 'active' || state === 'paused') return 'now';
  if (state === 'closed') return 'previous';
  return 'fresh';
}

function handleSSEFolders(folders) {
  liveState.switcher = {
    sessions: folders.map(f => ({
      id: f.path || f.name,
      project: f.name,
      status: mapFolderState(f.state),
      backendState: f.state,
      humanSessionCount: f.humanSessionCount || 0,
      updated: f.lastActive,
      last_message: f.handoffPurpose || '',
      context_pct: f.contextPct || 0,
      sessions: f.sessions || [],
    })),
  };

  // Auto-connect: hash, first active, or open switcher
  if (!sseCurrentFolder) {
    let target = null;
    if (location.hash.length > 1) {
      const hashName = location.hash.slice(1);
      target = folders.find(f => f.name === hashName || f.path === hashName);
    }
    if (!target) target = folders.find(f => f.state === 'active');
    if (target) {
      sseConnectFolder(target);
    } else {
      switcherOpen = true;
    }
  }
  sseRender();
}

function handleSSEState(data) {
  // Bridge broadcasts: { session: folderName, ...getState() }
  // getState().session is {id, model, project, context_pct} â€” overwrites the string
  // (later properties win in spread). So data.session is the object.

  if (data.messages) {
    console.log('[bb] state snapshot:', data.messages.length, 'msgs');
    liveState.messages = data.messages;
    toolCompletedSinceLastContent = false; // state snapshot = fresh start
  }
  if (data.session && typeof data.session === 'object') {
    liveState.session = { ...liveState.session, ...data.session };
  }
  if (data.status) liveState.status = data.status;
  if (data.status === 'working') lastPushTag = null; // new turn â€” allow next idle notification
  if (data.slashCommands !== undefined) liveState.slashCommands = data.slashCommands;
  if (data.status === 'idle') {
    liveState._activity = null;
    // Local notification when Claude finishes (page unfocused)
    const folder = sseCurrentFolder || '';
    pushNotify(`Claude finished in ${folder}`, {
      tag: `gueridon-done-${folder}`,
      folder,
    });
  }

  sseRender();
}

function handleSSEDelta(data) {
  switch (data.type) {
    case 'status':
      liveState.status = data.status;
      if (data.status === 'idle') liveState._activity = null;
      if (data.status === 'working') {
        lastPushTag = null; // new turn â€” allow next idle notification
      }
      break;

    case 'message_start':
      toolCompletedSinceLastContent = false;
      // Ensure an assistant skeleton exists â€” but don't push a duplicate if
      // the last message is already an assistant (multi-API-call turns).
      ensureAssistantMessage();
      console.log('[bb] message_start, now', liveState.messages.length, 'msgs');
      break;

    case 'activity':
      liveState._activity = data.activity;
      liveState.status = 'working';
      // Ensure an assistant message exists for incoming content/tool deltas
      ensureAssistantMessage();
      break;

    case 'content': {
      const msg = ensureAssistantMessage();
      msg.content = data.text;
      break;
    }

    case 'tool_start': {
      const msg = ensureAssistantMessage();
      if (!msg.tool_calls) msg.tool_calls = [];
      // Ensure we have an entry at this index
      while (msg.tool_calls.length <= data.index) {
        msg.tool_calls.push({ name: '', status: 'running', input: '', output: null, collapsed: true });
      }
      msg.tool_calls[data.index] = {
        name: data.name,
        status: 'running',
        input: data.input || '',
        output: null,
        collapsed: true,
      };
      break;
    }

    case 'tool_complete': {
      const last = liveState.messages[liveState.messages.length - 1];
      if (last?.tool_calls?.[data.index]) {
        last.tool_calls[data.index].status = data.status;
        if (data.output) last.tool_calls[data.index].output = data.output;
      }
      toolCompletedSinceLastContent = true;
      break;
    }

    case 'ask_user':
      showAskUserOverlay(data.questions, data.toolCallId, {
        els: askEls,
        onAnswer(answer) {
          ssePostPrompt(sseCurrentFolder, answer);
          liveState.messages.push({ role: 'user', content: answer });
          sseRender();
        },
        onDismiss() { ta.focus(); },
      });
      break;

    case 'thinking_content': {
      const msg = ensureAssistantMessage();
      msg.thinking = data.text;
      break;
    }

    case 'api_error':
      liveState.status = 'idle';
      liveState._activity = null;
      liveState.messages.push({ role: 'assistant', content: data.error });
      break;
  }
  sseRender();
}

// After tool_complete, the next content/thinking delta means a new inner API call
// has started â€” Claude processed tool results and is responding again. Without this,
// ensureAssistantMessage reuses the existing message and new text overwrites the old.
let toolCompletedSinceLastContent = false;

/** Ensure the last message is an assistant message â€” create one if not. */
function ensureAssistantMessage() {
  const last = liveState.messages[liveState.messages.length - 1];
  if (last && last.role === 'assistant' && !toolCompletedSinceLastContent) return last;
  toolCompletedSinceLastContent = false;
  const msg = { role: 'assistant', content: null };
  liveState.messages.push(msg);
  return msg;
}

async function ssePostSession(folderName, sessionId) {
  try {
    const body = sessionId ? { sessionId } : {};
    const res = await fetch(`${bridgeUrl}/session/${encodeURIComponent(folderName)}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-Client-ID': sseClientId },
      body: JSON.stringify(body),
    });
    if (!res.ok) { console.error('[bb] POST /session failed:', res.status); reportError('POST /session failed: ' + res.status); }
  } catch (err) {
    console.error('[bb] POST /session error:', err);
    reportError('POST /session error: ' + err);
  }
}

async function ssePostPrompt(folderName, text) {
  try {
    const res = await fetch(`${bridgeUrl}/prompt/${encodeURIComponent(folderName)}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-Client-ID': sseClientId },
      body: JSON.stringify({ text }),
    });
    if (!res.ok) {
      console.error('[bb] POST /prompt failed:', res.status);
      reportError('POST /prompt failed: ' + res.status);
      return { ok: false };
    }
    const data = await res.json();
    return { ok: true, queued: !!data.queued, delivered: !!data.delivered };
  } catch (err) {
    console.error('[bb] POST /prompt error:', err);
    reportError('POST /prompt error: ' + err);
    return { ok: false };
  }
}

async function ssePostAbort(folderName) {
  try {
    await fetch(`${bridgeUrl}/abort/${encodeURIComponent(folderName)}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-Client-ID': sseClientId },
    });
  } catch (err) {
    console.error('[bb] POST /abort error:', err);
    reportError('POST /abort error: ' + err);
  }
}

async function ssePostExit(folderName) {
  try {
    await fetch(`${bridgeUrl}/exit/${encodeURIComponent(folderName)}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-Client-ID': sseClientId },
    });
  } catch (err) {
    console.error('[bb] POST /exit error:', err);
    reportError('POST /exit error: ' + err);
  }
}

async function exitSession() {
  if (!bridgeUrl || !sseCurrentFolder) return;
  await ssePostExit(sseCurrentFolder);
  sseCurrentFolder = null;
  liveState.session = {};
  liveState.messages = [];
  liveState.status = 'idle';
  liveState._activity = null;
  liveState.slashCommands = null;
  location.hash = '';
  switcherOpen = true;
  fetch(bridgeUrl + '/folders')
    .then(r => r.json())
    .then(d => { if (d.folders) handleSSEFolders(d.folders); })
    .catch(() => {});
  sseRender();
}

// showAskUserOverlay, hideAskUserOverlay now in /render-overlays.js

function sseConnectFolder(folder, sessionId) {
  const name = folder.name || folder;
  // Allow reconnect to same folder if switching sessions
  if (sseCurrentFolder === name && !sessionId) return;
  sseCurrentFolder = name;
  liveState.session = { project: name };
  liveState.messages = [];
  liveState.status = 'idle';
  liveState._activity = null;
  location.hash = name;
  stagedDeposits = [];
  renderStagedDeposits();
  ssePostSession(name, sessionId);
  sseRender();
}

let sseRenderQueued = false;
function refreshPlaceholder() {
  updatePlaceholder(document.querySelector('.input-field'), {
    currentFolder: sseCurrentFolder,
    connection: liveState.connection,
    status: liveState.status,
    activity: liveState._activity,
    model: liveState.session?.model,
  });
}

function sseRender() {
  if (sseRenderQueued) return;
  sseRenderQueued = true;
  requestAnimationFrame(() => {
    sseRenderQueued = false;
    cachedState = liveState;
    renderStatusBar(liveState, chromeEls);
    // Auto-scroll if user is near the bottom (within 150px).
    // Replaces scroll-snap which fought iOS keyboard animation.
    const scrollGap = document.documentElement.scrollHeight - window.scrollY - window.innerHeight;
    const wasNearBottom = scrollGap < 150;

    renderMessages(document.getElementById('messages'), liveState.messages, {
      status: liveState.status,
      connection: liveState.connection,
      activity: liveState._activity,
      onError: reportError,
    });

    if (wasNearBottom) {
      window.scrollTo({ top: document.body.scrollHeight });
    }
    refreshSwitcher();
    refreshSendButton();
    // Show action buttons when any folder is connected (local commands always available)
    const hasFolder = !!sseCurrentFolder;
    document.getElementById('slashBtn').classList.toggle('visible', hasFolder);
    document.getElementById('fileBtn').classList.toggle('visible', hasFolder);
    refreshPlaceholder();
  });
}

// Start SSE if configured
function initSSE() {
  sseConnect();
  window.addEventListener('hashchange', () => {
    const folder = location.hash.slice(1);
    if (folder && folder !== sseCurrentFolder) {
      sseConnectFolder({ name: folder });
    }
  });
}

if (bridgeUrl) {
  initSSE();
} else {
  // Auto-discover: probe same-origin /folders (when served by the bridge itself).
  fetch('/folders').then((res) => {
    if (res.ok) {
      bridgeUrl = location.origin;
      initSSE();
    }
  }).catch(() => {});
}

// === Rendering helpers ===

// Render functions from client/*.js modules (window.Gdn namespace)
const { esc, trimText, trimToolOutput, truncateThinking, buildDepositNoteClient, THINKING_TRUNCATE,
        renderChip, renderThinkingChip, renderLocalCommand, attachCopyButton,
        addCopyButtons, renderUserBubble, renderMessages,
        renderStatusBar, renderSwitcher, updatePlaceholder, updateSendButton,
        showAskUserOverlay, hideAskUserOverlay,
        getSlashCommands, renderSlashList, openSlashSheet,
        showStagedError: _showStagedError, renderStagedDeposits: _renderStagedDeposits } = Gdn;

// Chrome element refs â€” cached once, passed to render functions
const chromeEls = {
  project: document.getElementById('project'),
  contextPct: document.getElementById('contextPct'),
  contextBtn: document.getElementById('contextBtn'),
  connectionDot: document.getElementById('switcherConnectionDot'),
  body: document.body,
};
const switcherEls = {
  switcher: document.getElementById('switcher'),
  list: document.getElementById('switcherList'),
  backdrop: document.getElementById('switcherBackdrop'),
  body: document.body,
};
const askEls = {
  backdrop: document.getElementById('askBackdrop'),
  sheet: document.getElementById('askSheet'),
  content: document.getElementById('askContent'),
};
const slashEls = {
  list: document.getElementById('slashList'),
  sheet: document.getElementById('slashSheet'),
  searchInput: document.getElementById('slashSearch'),
};
const stagedContainer = document.getElementById('stagedDeposits');

// Orchestrator wrappers â€” bind mutable state to module functions
function showStagedError(msg) { _showStagedError(msg, stagedContainer); }
function renderStagedDeposits() {
  _renderStagedDeposits(stagedDeposits, {
    container: stagedContainer,
    onRemove(i) { stagedDeposits.splice(i, 1); renderStagedDeposits(); refreshSendButton(); },
  });
}

// Configure marked â€” GFM for tables/task lists/strikethrough, no <br> on single newlines
marked.setOptions({ gfm: true, breaks: false });


// renderStatusBar, renderSwitcher, updatePlaceholder, updateSendButton now in /render-chrome.js

function refreshSwitcher() {
  renderSwitcher(cachedState || liveState, {
    switcherOpen,
    currentFolder: sseCurrentFolder,
    expandedFolder: switcherExpandedFolder,
    filter: document.getElementById('switcherSearch').value.trim().toLowerCase(),
    els: switcherEls,
    onConnect: (folder, sessionId) => {
      if (!bridgeUrl) return;
      sseConnectFolder(folder, sessionId);
      closeSwitcher();
    },
    onExpand: (folder) => {
      switcherExpandedFolder = folder;
      refreshSwitcher();
    },
    onCreate: (name) => {
      if (!bridgeUrl) return;
      fetch(bridgeUrl + '/folders', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(name ? { name } : {}),
      })
        .then(r => { if (!r.ok) return r.json().then(e => Promise.reject(e)); return r.json(); })
        .then(d => {
          sseConnectFolder({ name: d.name, path: d.path });
          closeSwitcher();
        })
        .catch(e => alert(e.error || 'Failed to create folder'));
    },
  });
}

// Bridge mode renders via its own event handlers â€” no render() call needed.

function closeSwitcher() {
  switcherOpen = false;
  document.getElementById('switcher').dataset.open = 'false';
  document.getElementById('switcherBackdrop').dataset.open = 'false';
  document.getElementById('switcherSearch').value = '';
  delete document.body.dataset.switcherOpen;
}

// Switcher: open/close uses client-side state, search re-filters without refetching
document.getElementById('switcherClose').addEventListener('click', closeSwitcher);
document.getElementById('switcherBackdrop').addEventListener('click', closeSwitcher);

// Swipe-down-to-dismiss on switcher (handle + header area)
{
  const switcherEl = document.getElementById('switcher');
  let swipeStartY = null;
  let swipeStartTranslate = 0;
  const handleEl = switcherEl.querySelector('.switcher-handle');
  const headerEl = switcherEl.querySelector('.switcher-header');

  // Tap handle to dismiss
  handleEl.addEventListener('click', closeSwitcher);

  // Swipe from handle or header area
  for (const el of [handleEl, headerEl]) {
    el.addEventListener('touchstart', (e) => {
      swipeStartY = e.touches[0].clientY;
      swipeStartTranslate = 0;
      switcherEl.style.transition = 'none';
    }, { passive: true });

    el.addEventListener('touchmove', (e) => {
      if (swipeStartY === null) return;
      const dy = e.touches[0].clientY - swipeStartY;
      if (dy > 0) {
        swipeStartTranslate = dy;
        switcherEl.style.transform = `translateY(${dy}px)`;
      }
    }, { passive: true });

    el.addEventListener('touchend', () => {
      switcherEl.style.transition = '';
      if (swipeStartTranslate > 80) {
        // Animate to bottom, then close state after transition
        switcherEl.style.transform = 'translateY(100%)';
        closeSwitcher();
        setTimeout(() => { switcherEl.style.transform = ''; }, 300);
      } else {
        switcherEl.style.transform = '';
      }
      swipeStartY = null;
    });
  }

  // Tap empty space below list items dismisses (the switcher itself, not just backdrop)
  document.getElementById('switcherList').addEventListener('click', (e) => {
    if (e.target === e.currentTarget) closeSwitcher();
  });
}

document.getElementById('switcherSearch').addEventListener('input', () => {
  if (cachedState) refreshSwitcher();
});

// Folder lozenge: tap opens session switcher
document.getElementById('folderBtn').addEventListener('click', () => {
  switcherOpen = true;
  switcherExpandedFolder = null;
  if (bridgeUrl) {
    fetch(bridgeUrl + '/folders')
      .then(r => r.json())
      .then(d => { if (d.folders) handleSSEFolders(d.folders); })
      .catch(() => {});
  }
  if (cachedState) refreshSwitcher();
});

// Context lozenge: tap when amber/red offers exit, long-press always offers exit
{
  const contextBtn = document.getElementById('contextBtn');
  let longPressTimer = null;
  let didLongPress = false;
  contextBtn.addEventListener('pointerdown', () => {
    didLongPress = false;
    longPressTimer = setTimeout(() => {
      didLongPress = true;
      if (sseCurrentFolder && confirm('End this session and return to the lobby?')) {
        exitSession();
      }
    }, 800);
  });
  contextBtn.addEventListener('pointerup', () => {
    clearTimeout(longPressTimer);
    if (didLongPress) return;
    const level = contextBtn.dataset.level;
    if ((level === 'low' || level === 'critical') && sseCurrentFolder) {
      if (confirm('Context is running high. End this session and start fresh?')) {
        exitSession();
      }
    }
  });
  contextBtn.addEventListener('pointercancel', () => clearTimeout(longPressTimer));
}

// Textarea setup â€” field-sizing: content handles auto-grow in CSS
const ta = document.querySelector('.input-field');
const msgEl = document.getElementById('messages');
const sendBtn = document.getElementById('sendBtn');

ta.addEventListener('input', () => refreshSendButton());

// Tapping input scrolls to latest â€” user wants to see recent messages to compose a reply
ta.addEventListener('focus', () => {
  window.scrollTo({ top: document.body.scrollHeight });
});

// Enter = newline. Shift+Enter or Cmd/Ctrl+Enter = submit.
ta.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && (e.shiftKey || e.metaKey || e.ctrlKey)) {
    e.preventDefault();
    sendBtn.click();
  }
});

function refreshSendButton() {
  updateSendButton(sendBtn, {
    hasText: ta.value.trim().length > 0,
    hasDeposits: stagedDeposits.length > 0,
    isDisconnected: document.body.dataset.connection === 'disconnected',
    isBusy: document.body.dataset.busy === 'true',
    isLive: !!bridgeUrl,
  });
}

// Staged deposits â€” files deposited on disk but not yet sent as prompt
let stagedDeposits = [];

// Send button tap
sendBtn.addEventListener('click', () => {
  // Request notification permission on first user gesture
  if (!pushPermissionGranted && 'Notification' in window && Notification.permission === 'default') {
    pushRequestPermission();
  }

  const isDisconnected = document.body.dataset.connection === 'disconnected';
  const isLive = !!bridgeUrl;
  if (isDisconnected && !isLive) return;

  const isBusy = document.body.dataset.busy === 'true';
  const hasText = ta.value.trim().length > 0;
  const hasDeposits = stagedDeposits.length > 0;
  const hasContent = hasText || hasDeposits;

  if (isBusy && !hasContent) {
    // Stop â€” abort Claude's current turn
    if (bridgeUrl && sseCurrentFolder) {
      ssePostAbort(sseCurrentFolder);
    }
  } else if (hasContent) {
    // Compose prompt: deposit notes first, then user text
    const parts = [];
    stagedDeposits.forEach(dep => {
      parts.push(buildDepositNoteClient(dep.folder, dep.manifest));
    });
    const userText = ta.value.trim();
    if (userText) parts.push(userText);
    const text = parts.join('\n\n');

    const msgId = 'msg-' + Date.now() + '-' + Math.random().toString(36).slice(2, 6);

    // Add message to DOM immediately (optimistic)
    const bubble = document.createElement('div');
    bubble.className = 'msg-user';
    let bubbleHTML = '';
    if (hasDeposits) {
      const fileRefs = stagedDeposits.flatMap(dep =>
        dep.manifest.files.map(f => f.deposited_as)
      );
      bubbleHTML += `<div class="msg-files">\u{1F4CE} ${fileRefs.join(', ')}</div>`;
    }
    if (userText) bubbleHTML += marked.parseInline(userText);
    bubble.innerHTML = bubbleHTML;
    bubble.dataset.msgId = msgId;
    msgEl.appendChild(bubble);

    // Also add to liveState so re-renders preserve it
    if (bridgeUrl) {
      liveState.messages.push({
        role: 'user', content: text, _msgId: msgId,
      });
    }

    // Send via SSE bridge
    if (bridgeUrl && sseCurrentFolder) {
      ssePostPrompt(sseCurrentFolder, text);
    }

    // Clear staging
    stagedDeposits = [];
    renderStagedDeposits();

    // Scroll to bottom after sending
    window.scrollTo({ top: document.body.scrollHeight });

    // Clear textarea
    ta.value = '';
    refreshSendButton();
  }
});

// --- Slash command sheet ---
// getSlashCommands, renderSlashList, openSlashSheet now in /render-overlays.js

const slashBtn = document.getElementById('slashBtn');

function handleSlashSelect(cmd) {
  if (cmd.name === 'exit') {
    if (sseCurrentFolder && confirm('End this session and return to the lobby?')) exitSession();
    return;
  }
  if (cmd.name === 'abort') {
    if (sseCurrentFolder) ssePostAbort(sseCurrentFolder);
    return;
  }
  ta.value = '/' + cmd.name;
  refreshSendButton();
  if (cmd.local) sendBtn.click();
  else ta.focus();
}

function slashOpts() {
  return { ccCommands: liveState.slashCommands, els: slashEls, onSelect: handleSlashSelect };
}

slashEls.searchInput.addEventListener('input', () => renderSlashList(slashEls.searchInput.value, slashOpts()));
slashBtn.addEventListener('click', () => openSlashSheet(slashOpts()));
slashEls.sheet.addEventListener('click', (e) => {
  if (e.target === slashEls.sheet) slashEls.sheet.classList.remove('open');
});

// Slash sheet: X button and swipe-down-to-dismiss
{
  const slashOverlay = slashEls.sheet;
  const slashInner = slashOverlay.querySelector('.slash-sheet');
  const slashHandle = slashInner.querySelector('.slash-sheet-handle');
  const slashHeader = slashInner.querySelector('.slash-sheet-header');

  function closeSlashSheet() { slashOverlay.classList.remove('open'); }

  // X button
  slashInner.querySelector('.slash-close').addEventListener('click', closeSlashSheet);

  // Tap handle to dismiss
  slashHandle.addEventListener('click', closeSlashSheet);

  // Swipe-down from handle or header area
  let swipeStartY = null;
  let swipeStartTranslate = 0;

  for (const el of [slashHandle, slashHeader]) {
    el.addEventListener('touchstart', (e) => {
      swipeStartY = e.touches[0].clientY;
      swipeStartTranslate = 0;
      slashInner.style.transition = 'none';
    }, { passive: true });

    el.addEventListener('touchmove', (e) => {
      if (swipeStartY === null) return;
      const dy = e.touches[0].clientY - swipeStartY;
      if (dy > 0) {
        swipeStartTranslate = dy;
        slashInner.style.transform = `translateY(${dy}px)`;
      }
    }, { passive: true });

    el.addEventListener('touchend', () => {
      slashInner.style.transition = '';
      if (swipeStartTranslate > 80) {
        slashInner.style.transform = 'translateY(100%)';
        closeSlashSheet();
        setTimeout(() => { slashInner.style.transform = ''; }, 300);
      } else {
        slashInner.style.transform = '';
      }
      swipeStartY = null;
    });
  }
}

// === File upload ===
const fileInput = document.createElement('input');
fileInput.type = 'file';
fileInput.accept = 'image/*,.txt,.md,.json,.csv,.pdf,.doc,.docx';
fileInput.multiple = true;
fileInput.style.display = 'none';
document.body.appendChild(fileInput);

// showStagedError, renderStagedDeposits now in /render-overlays.js
// Replicate server/upload.ts:buildDepositNote exactly â€” if this drifts,
// staged vs non-staged uploads produce different prompts for CC.

function uploadFiles(files) {
  if (!files.length) return;
  if (!sseCurrentFolder || !bridgeUrl) {
    showStagedError('Connect to a folder first');
    return;
  }
  const fileBtn = document.getElementById('fileBtn');
  const targetFolder = sseCurrentFolder;
  const form = new FormData();
  for (const f of files) form.append('file', f);

  fileBtn.classList.add('uploading');
  fetch(`${bridgeUrl}/upload/${encodeURIComponent(targetFolder)}?stage=true`, {
    method: 'POST',
    body: form,
  })
    .then(r => r.json())
    .then(data => {
      if (data.error) {
        showStagedError(data.error);
        return;
      }
      if (sseCurrentFolder !== targetFolder) return;
      stagedDeposits.push({ folder: data.folder, manifest: data.manifest });
      renderStagedDeposits();
      refreshSendButton();
    })
    .catch((err) => { reportError('POST /upload error: ' + err); showStagedError('Upload failed'); })
    .finally(() => fileBtn.classList.remove('uploading'));
}

document.getElementById('fileBtn').addEventListener('click', () => {
  fileInput.click();
});

fileInput.addEventListener('change', () => {
  uploadFiles(fileInput.files);
  fileInput.value = '';
});

// Drag and drop â€” document-level with overlay
const dropOverlay = document.getElementById('dropOverlay');
let dragCounter = 0;

document.addEventListener('dragenter', (e) => {
  e.preventDefault();
  if (e.dataTransfer?.types.includes('Files')) {
    dragCounter++;
    dropOverlay.classList.add('active');
  }
});

document.addEventListener('dragover', (e) => {
  e.preventDefault();
  if (e.dataTransfer) e.dataTransfer.dropEffect = 'copy';
});

document.addEventListener('dragleave', (e) => {
  e.preventDefault();
  dragCounter--;
  if (dragCounter <= 0) {
    dragCounter = 0;
    dropOverlay.classList.remove('active');
  }
});

document.addEventListener('drop', (e) => {
  e.preventDefault();
  dragCounter = 0;
  dropOverlay.classList.remove('active');
  if (e.dataTransfer?.files.length) {
    if (!sseCurrentFolder || !bridgeUrl) {
      showStagedError('Connect to a folder first');
      return;
    }
    uploadFiles(e.dataTransfer.files);
  }
});
</script>
</body>
</html>
