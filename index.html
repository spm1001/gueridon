<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>GuÃ©ridon</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/icon-192.svg" type="image/svg+xml">
<meta name="theme-color" content="#1a1a1a">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="stylesheet" href="/style.css">
</head>
<body>

  <div class="switcher-backdrop" id="switcherBackdrop"></div>
  <div class="switcher" id="switcher">
    <div class="switcher-handle"></div>
    <div class="switcher-header">
      <span class="status-connection" id="switcherConnectionDot"></span>
      <input class="switcher-search" id="switcherSearch" type="text" placeholder="Filter sessionsâ€¦">
      <button class="switcher-close" id="switcherClose" aria-label="Close">&#x2715;</button>
    </div>
    <div class="switcher-list" id="switcherList"></div>
  </div>

  <div class="ask-backdrop" id="askBackdrop"></div>
  <div class="ask-sheet" id="askSheet">
    <div class="ask-handle"></div>
    <div id="askContent"></div>
  </div>

  <div class="messages" id="messages"></div>


  <div class="slash-sheet-overlay" id="slashSheet">
    <div class="slash-sheet">
      <div class="slash-sheet-handle"></div>
      <div class="slash-sheet-title">Commands</div>
      <div id="slashList"></div>
    </div>
  </div>

  <div class="input-area">
    <textarea class="input-field" placeholder="Message Claude..." rows="1"></textarea>
    <div class="staged-deposits" id="stagedDeposits"></div>
    <div class="btn-bar">
      <button class="btn-circle btn-file" aria-label="Attach" id="fileBtn">+</button>
      <button class="btn-circle btn-slash" aria-label="Commands" id="slashBtn">/</button>
      <button class="btn-lozenge folder" id="folderBtn"><span class="label" id="project"></span></button>
      <button class="btn-lozenge context" id="contextBtn"><span class="pct" id="contextPct"></span><span class="push-denied" id="pushDenied" title="Notifications blocked">ðŸ”‡</span></button>
      <button class="btn-circle btn-send" aria-label="Send" id="sendBtn">&#x2191;</button>
    </div>
  </div>

<script src="/marked.js"></script>
<script>
// === Client error reporting ===
// Captures unhandled errors and promise rejections, sends to bridge.
// Fire-and-forget â€” never blocks or throws.
{
  const reported = new Set();
  function reportError(message, stack) {
    const key = message + (stack || '');
    if (reported.has(key)) return;
    reported.add(key);
    setTimeout(() => reported.delete(key), 5000); // dedup window
    try {
      fetch('/client-error', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message, stack, userAgent: navigator.userAgent, url: location.href }),
      }).catch(() => {}); // swallow fetch failures
    } catch { /* swallow */ }
  }
  window.addEventListener('error', (e) => reportError(e.message, e.error?.stack));
  window.addEventListener('unhandledrejection', (e) => reportError(String(e.reason), e.reason?.stack));
}

let cachedState = null;
let switcherOpen = false;
let switcherExpandedFolder = null; // folder name currently expanded in switcher
let userScrolledUp = false; // true when user has scrolled away from bottom

// === Mode detection ===
const params = new URLSearchParams(location.search);
let bridgeUrl = params.get('bridge'); // Explicit bridge URL: ?bridge=http://kube:3001

// === iOS standalone viewport fix ===
// iOS reports viewport height shorter than the actual screen in standalone mode.
// CSS viewport units (dvh, vh) and position:fixed are all capped at this wrong value.
// Force html+body to screen.height which IS the real renderable area.
// iOS standalone: force full screen height, and resize when keyboard opens.
// Without this, iOS reports viewport height shorter than the actual screen (793px vs 852px)
// and the messages area extends behind the keyboard, blocking scroll-to-top.
{
  const isStandalone = window.matchMedia('(display-mode: standalone)').matches;
  if (isStandalone) {
    document.documentElement.style.height = screen.height + 'px';
    document.body.style.height = screen.height + 'px';
  }
  if (window.visualViewport) {
    const inputArea = document.querySelector('.input-area');
    const refHeight = window.visualViewport.height;
    window.visualViewport.addEventListener('resize', () => {
      const keyboardOpen = window.visualViewport.height < refHeight - 100;
      inputArea.classList.toggle('keyboard-open', keyboardOpen);
      if (isStandalone) {
        const h = (keyboardOpen ? window.visualViewport.height : screen.height) + 'px';
        document.documentElement.style.height = h;
        document.body.style.height = h;
        window.scrollTo(0, 0);
      }
    });
  }
}

// === Push notifications ===
let swRegistration = null;
let swReady = null;
let pushPermissionGranted = false;

// Register service worker immediately (needed for push + PWA install)
if ('serviceWorker' in navigator) {
  swReady = navigator.serviceWorker.register('/sw.js').then(
    (reg) => { swRegistration = reg; return reg; },
    (e) => { console.warn('[push] SW registration failed:', e); return null; },
  );
  // Listen for notification click deep-links from service worker
  navigator.serviceWorker.addEventListener('message', (ev) => {
    if (ev.data?.type === 'notificationClick' && ev.data.folder) {
      location.hash = ev.data.folder;
    }
  });
} else {
  swReady = Promise.resolve(null);
}

/** Request notification permission. Must be called from user gesture. */
async function pushRequestPermission() {
  if (!('Notification' in window)) return false;
  if (Notification.permission === 'granted') { pushPermissionGranted = true; return true; }
  if (Notification.permission === 'denied') {
    document.getElementById('pushDenied').classList.add('visible');
    return false;
  }
  const result = await Notification.requestPermission();
  pushPermissionGranted = result === 'granted';
  if (!pushPermissionGranted) {
    document.getElementById('pushDenied').classList.add('visible');
  }
  return pushPermissionGranted;
}

// Push denied indicator: tap shows instructions
document.getElementById('pushDenied').addEventListener('click', (e) => {
  e.stopPropagation();
  alert('Notifications are blocked.\n\nTo re-enable:\niOS: Settings â†’ Notifications â†’ Safari\nAndroid: Site settings â†’ Notifications');
});

/** Subscribe to push via bridge. Call after hello provides VAPID key. */
async function pushSubscribe(vapidPublicKey) {
  await swReady;
  if (!swRegistration || !vapidPublicKey || !('PushManager' in window)) return;
  try {
    let sub = await swRegistration.pushManager.getSubscription();
    if (!sub) {
      const padding = '='.repeat((4 - (vapidPublicKey.length % 4)) % 4);
      const b64 = (vapidPublicKey + padding).replace(/-/g, '+').replace(/_/g, '/');
      const raw = atob(b64);
      const key = new Uint8Array(raw.length);
      for (let i = 0; i < raw.length; i++) key[i] = raw.charCodeAt(i);
      sub = await swRegistration.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: key });
    }
    // POST subscription to bridge
    if (bridgeUrl) {
      const subHeaders = { 'Content-Type': 'application/json' };
      if (ssePushToken) subHeaders['X-Push-Token'] = ssePushToken;
      await fetch(`${bridgeUrl}/push/subscribe`, {
        method: 'POST',
        headers: subHeaders,
        body: JSON.stringify(sub.toJSON()),
      });
      console.log('[push] Subscription sent to bridge');
    }
  } catch (e) {
    console.warn('[push] Subscription failed:', e);
  }
}

/** Show local notification (when page is unfocused and SW available). */
function pushNotify(body, opts = {}) {
  if (document.hasFocus()) return;
  if (!pushPermissionGranted && Notification.permission !== 'granted') return;
  const title = 'GuÃ©ridon';
  if (swRegistration) {
    swRegistration.showNotification(title, {
      body,
      icon: '/icon-192.svg',
      badge: '/icon-192.svg',
      tag: opts.tag || 'gueridon-default',
      renotify: true,
      vibrate: opts.vibrate || [200],
      data: { folder: opts.folder || '' },
    });
  } else {
    new Notification(title, { body, icon: '/icon-192.svg', tag: opts.tag || 'gueridon-default' });
  }
}

// === SSE bridge client ===
let sseSource = null;
let sseClientId = 'bb-' + Date.now().toString(36) + Math.random().toString(36).slice(2, 6);
let sseCurrentFolder = null; // folder name we're connected to
let ssePushToken = null;     // bridge-issued token for push subscribe/unsubscribe auth (gdn-ricocu)
let sseWatchdog = null;
const SSE_WATCHDOG_MS = 65_000; // 60s silence = dead (pings every 30s + margin)

// Live state â€” shared between SSE and WS modes
let liveState = {
  session: {},
  messages: [],
  connection: 'disconnected',
  status: 'idle',
  switcher: null,
  _activity: null,
};

function sseConnect() {
  if (!bridgeUrl) return;
  if (sseSource) { sseSource.close(); sseSource = null; }

  const url = `${bridgeUrl}/events?clientId=${encodeURIComponent(sseClientId)}`;
  sseSource = new EventSource(url);

  sseSource.addEventListener('hello', (ev) => {
    const data = JSON.parse(ev.data);
    if (data.version !== 1) {
      console.error('[bb] protocol version mismatch, reloading');
      location.reload();
      return;
    }
    liveState.connection = 'connected';
    sseResetWatchdog();
    sseRender();

    // Store bridge-issued push token for subscribe/unsubscribe auth (gdn-ricocu)
    ssePushToken = data.pushToken || null;

    // Subscribe to push if bridge provides VAPID key
    if (data.vapidPublicKey) {
      pushSubscribe(data.vapidPublicKey);
    }

    // Re-establish session from hash or previous state.
    // Clear stale messages â€” the POST /session response sends a fresh state snapshot.
    // Without this, deltas arriving between reconnect and state snapshot accumulate
    // on top of old messages, causing visual duplication.
    if (sseCurrentFolder) {
      // Always clear stale messages when we have an active folder â€”
      // both auto-reconnect (Last-Event-ID) and watchdog reconnect (fresh
      // EventSource) need a clean slate before the state snapshot arrives.
      liveState.messages = [];
      ssePostSession(sseCurrentFolder);
    } else if (location.hash.length > 1) {
      ssePostSession(location.hash.slice(1));
    }
  });

  sseSource.addEventListener('folders', (ev) => {
    const data = JSON.parse(ev.data);
    sseResetWatchdog();
    handleSSEFolders(data.folders || []);
  });

  sseSource.addEventListener('state', (ev) => {
    const data = JSON.parse(ev.data);
    sseResetWatchdog();
    // Discard events for wrong folder (data.folder is the routing key; data.session is the session object)
    if (sseCurrentFolder && data.folder && data.folder !== sseCurrentFolder) return;
    handleSSEState(data);
  });

  sseSource.addEventListener('delta', (ev) => {
    const data = JSON.parse(ev.data);
    sseResetWatchdog();
    if (sseCurrentFolder && data.folder && data.folder !== sseCurrentFolder) return;
    handleSSEDelta(data);
  });

  sseSource.addEventListener('ping', () => {
    sseResetWatchdog();
  });

  sseSource.onerror = () => {
    liveState.connection = 'disconnected';
    liveState._activity = null;
    sseRender();
    // EventSource auto-reconnects â€” no manual retry needed
  };

  sseSource.onopen = () => {
    // Fires on initial connect and each reconnect
    sseResetWatchdog();
  };
}

function sseResetWatchdog() {
  if (sseWatchdog) clearTimeout(sseWatchdog);
  sseWatchdog = setTimeout(() => {
    console.log('[bb] SSE watchdog: no events for 65s, reconnecting');
    if (sseSource) { sseSource.close(); sseSource = null; }
    liveState.connection = 'disconnected';
    sseRender();
    sseConnect();
  }, SSE_WATCHDOG_MS);
}

function mapFolderState(state) {
  if (state === 'active' || state === 'paused') return 'now';
  if (state === 'closed') return 'previous';
  return 'fresh';
}

function handleSSEFolders(folders) {
  liveState.switcher = {
    sessions: folders.map(f => ({
      id: f.path || f.name,
      project: f.name,
      status: mapFolderState(f.state),
      backendState: f.state,
      humanSessionCount: f.humanSessionCount || 0,
      updated: f.lastActive,
      last_message: f.handoffPurpose || '',
      context_pct: f.contextPct || 0,
      sessions: f.sessions || [],
    })),
  };

  // Auto-connect: hash, first active, or open switcher
  if (!sseCurrentFolder) {
    let target = null;
    if (location.hash.length > 1) {
      const hashName = location.hash.slice(1);
      target = folders.find(f => f.name === hashName || f.path === hashName);
    }
    if (!target) target = folders.find(f => f.state === 'active');
    if (target) {
      sseConnectFolder(target);
    } else {
      switcherOpen = true;
    }
  }
  sseRender();
}

function handleSSEState(data) {
  // Bridge broadcasts: { session: folderName, ...getState() }
  // getState().session is {id, model, project, context_pct} â€” overwrites the string
  // (later properties win in spread). So data.session is the object.

  if (data.messages) {
    console.log('[bb] state snapshot:', data.messages.length, 'msgs');
    liveState.messages = data.messages;
  }
  if (data.session && typeof data.session === 'object') {
    liveState.session = { ...liveState.session, ...data.session };
  }
  if (data.status) liveState.status = data.status;
  if (data.slashCommands !== undefined) liveState.slashCommands = data.slashCommands;
  if (data.status === 'idle') {
    liveState._activity = null;
    // Local notification when Claude finishes (page unfocused)
    const folder = sseCurrentFolder || '';
    pushNotify(`Claude finished in ${folder}`, {
      tag: `gueridon-done-${folder}`,
      folder,
    });
  }

  sseRender();
}

function handleSSEDelta(data) {
  switch (data.type) {
    case 'status':
      liveState.status = data.status;
      if (data.status === 'idle') liveState._activity = null;
      // Working status = CC ingested queued messages â€” clear queued/pending flags
      if (data.status === 'working') {
        for (const msg of liveState.messages) {
          if (msg.queued || msg.pending) {
            msg.queued = false;
            msg.pending = false;
          }
        }
      }
      break;

    case 'message_start':
      // Ensure an assistant skeleton exists â€” but don't push a duplicate if
      // the last message is already an assistant (multi-API-call turns).
      ensureAssistantMessage();
      console.log('[bb] message_start, now', liveState.messages.length, 'msgs');
      break;

    case 'activity':
      liveState._activity = data.activity;
      liveState.status = 'working';
      // Ensure an assistant message exists for incoming content/tool deltas
      ensureAssistantMessage();
      break;

    case 'content': {
      const msg = ensureAssistantMessage();
      msg.content = data.text;
      break;
    }

    case 'tool_start': {
      const msg = ensureAssistantMessage();
      if (!msg.tool_calls) msg.tool_calls = [];
      // Ensure we have an entry at this index
      while (msg.tool_calls.length <= data.index) {
        msg.tool_calls.push({ name: '', status: 'running', input: '', output: null, collapsed: true });
      }
      msg.tool_calls[data.index] = {
        name: data.name,
        status: 'running',
        input: data.input || '',
        output: null,
        collapsed: true,
      };
      break;
    }

    case 'tool_complete': {
      const last = liveState.messages[liveState.messages.length - 1];
      if (last?.tool_calls?.[data.index]) {
        last.tool_calls[data.index].status = data.status;
        if (data.output) last.tool_calls[data.index].output = data.output;
      }
      break;
    }

    case 'ask_user':
      showAskUserOverlay(data.questions, data.toolCallId);
      break;

    case 'thinking_content': {
      const msg = ensureAssistantMessage();
      msg.thinking = data.text;
      break;
    }

    case 'api_error':
      liveState.status = 'idle';
      liveState._activity = null;
      liveState.messages.push({ role: 'assistant', content: data.error });
      break;
  }
  sseRender();
}

/** Ensure the last message is an assistant message â€” create one if not. */
function ensureAssistantMessage() {
  const last = liveState.messages[liveState.messages.length - 1];
  if (last && last.role === 'assistant') return last;
  const msg = { role: 'assistant', content: null };
  liveState.messages.push(msg);
  return msg;
}

async function ssePostSession(folderName, sessionId) {
  try {
    const body = sessionId ? { sessionId } : {};
    const res = await fetch(`${bridgeUrl}/session/${encodeURIComponent(folderName)}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-Client-ID': sseClientId },
      body: JSON.stringify(body),
    });
    if (!res.ok) console.error('[bb] POST /session failed:', res.status);
  } catch (err) {
    console.error('[bb] POST /session error:', err);
  }
}

async function ssePostPrompt(folderName, text) {
  try {
    const res = await fetch(`${bridgeUrl}/prompt/${encodeURIComponent(folderName)}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-Client-ID': sseClientId },
      body: JSON.stringify({ text }),
    });
    if (!res.ok) {
      console.error('[bb] POST /prompt failed:', res.status);
      return { ok: false };
    }
    const data = await res.json();
    return { ok: true, queued: !!data.queued, delivered: !!data.delivered };
  } catch (err) {
    console.error('[bb] POST /prompt error:', err);
    return { ok: false };
  }
}

async function ssePostAbort(folderName) {
  try {
    await fetch(`${bridgeUrl}/abort/${encodeURIComponent(folderName)}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-Client-ID': sseClientId },
    });
  } catch (err) {
    console.error('[bb] POST /abort error:', err);
  }
}

async function ssePostExit(folderName) {
  try {
    await fetch(`${bridgeUrl}/exit/${encodeURIComponent(folderName)}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-Client-ID': sseClientId },
    });
  } catch (err) {
    console.error('[bb] POST /exit error:', err);
  }
}

async function exitSession() {
  if (!bridgeUrl || !sseCurrentFolder) return;
  await ssePostExit(sseCurrentFolder);
  sseCurrentFolder = null;
  liveState.session = {};
  liveState.messages = [];
  liveState.status = 'idle';
  liveState._activity = null;
  liveState.slashCommands = null;
  location.hash = '';
  switcherOpen = true;
  fetch(bridgeUrl + '/folders')
    .then(r => r.json())
    .then(d => { if (d.folders) handleSSEFolders(d.folders); })
    .catch(() => {});
  sseRender();
}

// === AskUserQuestion overlay ===

function showAskUserOverlay(questions, toolCallId) {
  const backdrop = document.getElementById('askBackdrop');
  const sheet = document.getElementById('askSheet');
  const content = document.getElementById('askContent');

  // Build overlay content
  let html = '';
  const isSingleImmediate = questions.length === 1 && !questions[0].multiSelect;

  questions.forEach((q, qi) => {
    html += `<div class="ask-header">${esc(q.header)}</div>`;
    html += `<div class="ask-question">${esc(q.question)}</div>`;
    html += `<div class="ask-options" data-qi="${qi}" data-multi="${q.multiSelect}">`;
    q.options.forEach((opt, oi) => {
      html += `<div class="ask-option" data-qi="${qi}" data-oi="${oi}" data-label="${esc(opt.label)}">`;
      if (q.multiSelect) {
        html += `<span class="ask-option-check">&#x2713;</span>`;
      }
      html += `<div>`;
      html += `<div class="ask-option-label">${esc(opt.label)}</div>`;
      if (opt.description) {
        html += `<div class="ask-option-desc">${esc(opt.description)}</div>`;
      }
      html += `</div></div>`;
    });
    html += `</div>`;
  });

  if (!isSingleImmediate) {
    html += `<button class="ask-confirm" id="askConfirm" data-visible="true">Send answers</button>`;
  }
  html += `<div class="ask-custom" id="askCustom">Type a custom answer instead</div>`;

  content.innerHTML = html;

  // Show overlay
  backdrop.dataset.open = 'true';
  sheet.dataset.open = 'true';

  // Option tap handlers
  content.querySelectorAll('.ask-option').forEach(opt => {
    opt.addEventListener('click', () => {
      const qi = opt.dataset.qi;
      const container = opt.closest('.ask-options');
      const isMulti = container.dataset.multi === 'true';

      if (isMulti) {
        // Toggle selection
        opt.dataset.selected = opt.dataset.selected === 'true' ? 'false' : 'true';
      } else {
        // Single-select: deselect siblings, select this one
        container.querySelectorAll('.ask-option').forEach(s => s.dataset.selected = 'false');
        opt.dataset.selected = 'true';

        // Single question + single select = immediate send
        if (isSingleImmediate) {
          sendAskUserAnswer(questions, toolCallId);
        }
      }
    });
  });

  // Confirm button (multi-select or multi-question)
  const confirmBtn = document.getElementById('askConfirm');
  if (confirmBtn) {
    confirmBtn.addEventListener('click', () => {
      sendAskUserAnswer(questions, toolCallId);
    });
  }

  // Custom answer â€” dismiss overlay, focus input
  document.getElementById('askCustom').addEventListener('click', () => {
    hideAskUserOverlay();
    document.querySelector('.input-field').focus();
  });

  // Backdrop tap dismisses
  backdrop.addEventListener('click', () => {
    hideAskUserOverlay();
    document.querySelector('.input-field').focus();
  });
}

function sendAskUserAnswer(questions, toolCallId) {
  // Collect selections
  const content = document.getElementById('askContent');
  let answer = '';

  if (questions.length === 1) {
    const selected = content.querySelectorAll('.ask-option[data-selected="true"]');
    const labels = Array.from(selected).map(s => s.dataset.label);
    answer = labels.join(', ');
  } else {
    // Multi-question: "Header: label1, label2\nHeader2: label3"
    const parts = [];
    questions.forEach((q, qi) => {
      const selected = content.querySelectorAll(`.ask-option[data-qi="${qi}"][data-selected="true"]`);
      const labels = Array.from(selected).map(s => s.dataset.label);
      if (labels.length > 0) {
        parts.push(`${q.header}: ${labels.join(', ')}`);
      }
    });
    answer = parts.join('\n');
  }

  if (answer && sseCurrentFolder) {
    ssePostPrompt(sseCurrentFolder, answer);
    // Show the answer as a user message
    liveState.messages.push({ role: 'user', content: answer });
    sseRender();
  }

  hideAskUserOverlay();
}

function hideAskUserOverlay() {
  document.getElementById('askBackdrop').dataset.open = 'false';
  document.getElementById('askSheet').dataset.open = 'false';
}

function sseConnectFolder(folder, sessionId) {
  const name = folder.name || folder;
  // Allow reconnect to same folder if switching sessions
  if (sseCurrentFolder === name && !sessionId) return;
  sseCurrentFolder = name;
  liveState.session = { project: name };
  liveState.messages = [];
  liveState.status = 'idle';
  liveState._activity = null;
  location.hash = name;
  stagedDeposits = [];
  renderStagedDeposits();
  ssePostSession(name, sessionId);
  sseRender();
}

let sseRenderQueued = false;
function updatePlaceholder() {
  const ta = document.querySelector('.input-field');
  if (!sseCurrentFolder) {
    ta.placeholder = 'Choose a folderâ€¦';
  } else if (liveState.connection === 'disconnected') {
    ta.placeholder = 'Reconnectingâ€¦';
  } else if (liveState.status === 'working') {
    const activity = liveState._activity;
    ta.placeholder = activity === 'writing' ? 'Claude is writingâ€¦' :
                     activity === 'tool' ? 'Claude is editingâ€¦' :
                     'Claude is thinkingâ€¦';
  } else {
    const model = liveState.session?.model;
    const short = model ? model.replace('claude-', '').replace(/-\d{8}$/, '') : '';
    ta.placeholder = short ? `Message ${short}â€¦` : 'Message Claudeâ€¦';
  }
}

function sseRender() {
  if (sseRenderQueued) return;
  sseRenderQueued = true;
  requestAnimationFrame(() => {
    sseRenderQueued = false;
    cachedState = liveState;
    renderStatusBar(liveState);
    renderMessages(liveState.messages);
    renderSwitcher(liveState);
    // Show action buttons when any folder is connected (local commands always available)
    const hasFolder = !!sseCurrentFolder;
    document.getElementById('slashBtn').classList.toggle('visible', hasFolder);
    document.getElementById('fileBtn').classList.toggle('visible', hasFolder);
    updatePlaceholder();
  });
}

// Start SSE if configured
function initSSE() {
  sseConnect();
  window.addEventListener('hashchange', () => {
    const folder = location.hash.slice(1);
    if (folder && folder !== sseCurrentFolder) {
      sseConnectFolder({ name: folder });
    }
  });
}

if (bridgeUrl) {
  initSSE();
} else {
  // Auto-discover: probe same-origin /folders (when served by the bridge itself).
  fetch('/folders').then((res) => {
    if (res.ok) {
      bridgeUrl = location.origin;
      initSSE();
    }
  }).catch(() => {});
}

// === Rendering helpers ===

function esc(s) {
  const d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}

// Configure marked â€” GFM for tables/task lists/strikethrough, no <br> on single newlines
marked.setOptions({ gfm: true, breaks: false });

// Inject copy buttons into <pre> blocks inside a container element
function addCopyButtons(container) {
  for (const pre of container.querySelectorAll('pre')) {
    if (pre.querySelector('.code-copy-btn')) continue;
    const btn = document.createElement('button');
    btn.className = 'code-copy-btn';
    btn.textContent = 'Copy';
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const code = pre.querySelector('code');
      const text = (code || pre).textContent;
      navigator.clipboard.writeText(text).then(() => {
        btn.textContent = 'Copied';
        setTimeout(() => { btn.textContent = 'Copy'; }, 1500);
      });
    });
    pre.appendChild(btn);
  }
}

// === Output trimming for small screens ===
// Transform pipeline: applied at block boundaries before rendering

function trimText(text) {
  if (!text) return text;
  // Strip <local-command-stdout> tags and trim /context output
  const stdoutRe = /<local-command-stdout>([\s\S]*?)<\/local-command-stdout>/g;
  text = text.replace(stdoutRe, (_, inner) => {
    // /context output: extract just the usage/cost summary lines
    if (inner.includes('Context:') || inner.includes('context window')) {
      const lines = inner.split('\n');
      const usageLines = lines.filter(l =>
        /^\s*Context:\s*\d/.test(l) || /token/i.test(l) || /^\s*Cost:/i.test(l) || /^\s*\d+%/.test(l)
      );
      return usageLines.length ? usageLines.join('\n').trim() : inner.trim();
    }
    return inner.trim();
  });
  return text;
}

function trimToolOutput(output, maxLines) {
  if (!output) return output;
  maxLines = maxLines || 30;
  const lines = output.split('\n');
  if (lines.length <= maxLines) return output;
  const headCount = Math.ceil(maxLines / 2);
  const tailCount = Math.floor(maxLines / 2);
  const hidden = lines.length - headCount - tailCount;
  return lines.slice(0, headCount).join('\n')
    + `\nâ€¦ ${hidden} lines hidden â€¦\n`
    + lines.slice(-tailCount).join('\n');
}

function renderLocalCommand(content) {
  // Extract inner content from <local-command-stdout> tags
  const match = content.match(/<local-command-stdout>([\s\S]*?)<\/local-command-stdout>/);
  const inner = match ? match[1].trim() : content;

  // Extract a one-line summary for the collapsed header
  // /context: "Model: claude-opus-4-6  Tokens: 73.3k / 200k (37%)"
  // /cost: the whole thing is short enough
  // /compact: "Compacted"
  let summary = '';
  const lines = inner.split('\n');
  // Look for the Tokens line (most useful for /context)
  const tokensLine = lines.find(l => /\*\*Tokens:\*\*/.test(l));
  if (tokensLine) {
    // Strip markdown bold markers
    summary = tokensLine.replace(/\*\*/g, '').trim();
  } else if (inner.length < 100) {
    // Short output like /compact or /cost â€” use as-is
    summary = inner.replace(/\n/g, ' ').trim();
  } else {
    // Fallback: first non-empty, non-heading line
    summary = lines.find(l => l.trim() && !l.startsWith('#')) || lines[0] || 'Command output';
    summary = summary.replace(/\*\*/g, '').trim();
  }

  const block = document.createElement('div');
  block.className = 'local-cmd';
  block.dataset.expanded = 'false';

  block.innerHTML = `
    <div class="local-cmd-header">
      <span class="tool-chevron">&#x25B8;</span>
      <span class="local-cmd-summary">${esc(summary)}</span>
    </div>
    <div class="local-cmd-body">${marked.parse(inner)}</div>
  `;

  block.querySelector('.local-cmd-header').addEventListener('click', () => {
    block.dataset.expanded = block.dataset.expanded === 'true' ? 'false' : 'true';
  });

  addCopyButtons(block);
  return block;
}

const THINKING_TRUNCATE = 500;

function truncateThinking(text) {
  if (text.length <= THINKING_TRUNCATE) return text;
  return text.slice(0, THINKING_TRUNCATE) + 'â€¦';
}

function renderThinkingChip(thinkingText) {
  const chip = document.createElement('div');
  chip.className = 'chip thinking-done';
  const truncated = truncateThinking(thinkingText);
  const needsMore = thinkingText.length > THINKING_TRUNCATE;

  chip.innerHTML =
    `<span class="c-status done" style="color:var(--accent)">&#x2726;</span>` +
    `<span class="c-name" style="color:var(--accent)">Thought</span>` +
    `<div class="c-detail">${esc(truncated)}` +
    (needsMore ? `<span class="thinking-more" style="color:var(--accent);cursor:pointer;display:block;margin-top:4px;font-size:0.55rem">Show full thinking</span>` : '') +
    `</div>`;

  chip.addEventListener('click', (e) => {
    if (e.target.classList.contains('thinking-more')) {
      // Replace truncated with full text
      const detail = chip.querySelector('.c-detail');
      detail.textContent = thinkingText;
      return;
    }
    chip.classList.toggle('expanded');
  });

  return chip;
}

function renderChip(tc) {
  const statusClass = tc.status === 'completed' ? 'done' : tc.status === 'running' ? 'run' : 'err';
  const statusIcon = tc.status === 'completed' ? '&#x2713;' :
                     tc.status === 'running' ? '&#x25cf;' : '&#x2717;';
  const chipClass = 'chip' + (tc.status === 'error' ? ' error' : '') + (tc.status === 'running' ? ' running' : '');

  const chip = document.createElement('div');
  chip.className = chipClass;
  chip.dataset.toolId = tc.name + '|' + (tc.input || '');

  const detail = tc.input + (tc.output ? '\n' + trimToolOutput(tc.output) : '');

  chip.innerHTML =
    `<span class="c-status ${statusClass}">${statusIcon}</span>` +
    `<span class="c-name">${esc(tc.name)}</span>` +
    (tc.input ? `<span class="c-path">${esc(tc.input)}</span>` : '') +
    `<div class="c-detail">${esc(detail)}</div>`;

  const copyBtn = document.createElement('button');
  copyBtn.className = 'code-copy-btn';
  copyBtn.textContent = 'Copy';
  copyBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    navigator.clipboard.writeText(detail).then(() => {
      copyBtn.textContent = 'Copied';
      setTimeout(() => { copyBtn.textContent = 'Copy'; }, 1500);
    });
  });
  chip.querySelector('.c-detail').appendChild(copyBtn);

  chip.addEventListener('click', () => {
    chip.classList.toggle('expanded');
  });

  return chip;
}

// Parse deposit notes out of user message content â†’ ðŸ“Ž file refs + remaining text
function renderUserBubble(content) {
  const DEPOSIT_END = 'manifest.json has full metadata. Read the files if relevant to our conversation.';
  let remaining = content;
  const fileNames = [];

  while (remaining.includes('[gu\u00E9ridon:upload]')) {
    const start = remaining.indexOf('[gu\u00E9ridon:upload]');
    const endIdx = remaining.indexOf(DEPOSIT_END, start);
    if (endIdx === -1) break;

    const block = remaining.slice(start, endIdx + DEPOSIT_END.length);
    const filePattern = /  - (\S+) \(/g;
    let m;
    while ((m = filePattern.exec(block)) !== null) fileNames.push(m[1]);

    remaining = remaining.slice(0, start) + remaining.slice(endIdx + DEPOSIT_END.length);
  }

  remaining = remaining.replace(/^\n+/, '').replace(/\n+$/, '');
  let html = '';
  if (fileNames.length > 0) html += `<div class="msg-files">\u{1F4CE} ${fileNames.join(', ')}</div>`;
  if (remaining) html += marked.parseInline(remaining);
  return html;
}

function renderMessages(messages) {
  // Dupe tripwire: detect consecutive assistant messages with identical content
  for (let i = 1; i < messages.length; i++) {
    const prev = messages[i - 1], cur = messages[i];
    if (prev.role === 'assistant' && cur.role === 'assistant' && prev.content && cur.content && prev.content === cur.content) {
      console.warn('[bb] DUPE TRIPWIRE: consecutive identical assistant messages at index', i, 'of', messages.length);
      reportError('dupe-tripwire: consecutive identical assistant messages at index ' + i);
    }
  }

  const el = document.getElementById('messages');

  // Snapshot expanded chips before rebuild
  const expandedChips = new Set();
  for (const chip of el.querySelectorAll('.chip.expanded')) {
    if (chip.dataset.toolId) expandedChips.add(chip.dataset.toolId);
  }
  const thinkingExpanded = !!el.querySelector('.chip.thinking-done.expanded, .chip.thinking.expanded');

  el.innerHTML = '';

  for (const msg of messages) {
    // Thinking chip â€” before content (thinking happened first, keeps visual position)
    const hasThinking = msg.thinking && msg.role === 'assistant';
    if (hasThinking) {
      const grid = document.createElement('div');
      grid.className = 'chip-grid';
      const chip = renderThinkingChip(msg.thinking);
      if (thinkingExpanded) chip.classList.add('expanded');
      grid.appendChild(chip);
      el.appendChild(grid);
    }

    // Text content
    if (msg.content !== null && msg.content !== undefined) {
      // Local command output â€” render as collapsible block
      if (msg.role === 'assistant' && msg.content.includes('<local-command-stdout>')) {
        el.appendChild(renderLocalCommand(msg.content));
      } else {
        const div = document.createElement('div');
        if (msg.role === 'user' && msg.synthetic) {
          div.className = 'msg-system';
          div.textContent = msg.content;
        } else if (msg.role === 'user') {
          div.className = 'msg-user';
          div.innerHTML = renderUserBubble(msg.content);
          if (msg._msgId) div.dataset.msgId = msg._msgId;
          if (msg.pending) div.dataset.pending = 'true';
          else if (msg.queued) div.dataset.queued = 'true';
        } else {
          div.className = 'msg-assistant';
          div.innerHTML = marked.parse(trimText(msg.content));
          addCopyButtons(div);
        }
        el.appendChild(div);
      }
    }

    // Tool calls â€” render as chip grid (after content)
    const hasTools = msg.tool_calls && msg.tool_calls.length;
    if (hasTools) {
      const grid = document.createElement('div');
      grid.className = 'chip-grid';
      for (const tc of msg.tool_calls) {
        const chip = renderChip(tc);
        if (expandedChips.has(chip.dataset.toolId)) chip.classList.add('expanded');
        grid.appendChild(chip);
      }
      el.appendChild(grid);
    }
  }

  // Activity chip â€” pulsing indicator at the end when Claude is working
  if (liveState.status === 'working' && liveState.connection !== 'disconnected') {
    const activity = liveState._activity || 'thinking';
    // Only show thinking/writing chips â€” tool activity is shown by the running chip itself
    if (activity === 'thinking' || activity === 'writing') {
      const label = activity === 'thinking' ? 'Thinkingâ€¦' : 'Writingâ€¦';
      const chip = document.createElement('div');
      chip.className = 'chip ' + activity;

      // During thinking, show accumulated text in expandable detail
      const lastMsg = liveState.messages[liveState.messages.length - 1];
      const thinkingText = activity === 'thinking' && lastMsg?.thinking ? lastMsg.thinking : null;
      if (thinkingText) {
        chip.innerHTML = `<span class="c-name">${label}</span>` +
          `<div class="c-detail">${esc(truncateThinking(thinkingText))}</div>`;
        if (thinkingExpanded) chip.classList.add('expanded');
        chip.addEventListener('click', () => chip.classList.toggle('expanded'));
      } else {
        chip.innerHTML = `<span class="c-name">${label}</span>`;
      }

      // Append to last chip-grid if one exists, otherwise create new grid
      const lastGrid = el.querySelector('.chip-grid:last-child');
      if (lastGrid && lastGrid === el.lastElementChild) {
        lastGrid.appendChild(chip);
      } else {
        const grid = document.createElement('div');
        grid.className = 'chip-grid';
        grid.appendChild(chip);
        el.appendChild(grid);
      }
    }
  }

  // Only auto-scroll if user hasn't scrolled up to read earlier content
  if (!userScrolledUp) {
    el.scrollTop = el.scrollHeight;
  }
}

// Track user scroll intent on the messages container
document.getElementById('messages').addEventListener('scroll', () => {
  const el = document.getElementById('messages');
  // "At bottom" = within 60px of the end (threshold for finger imprecision)
  const atBottom = el.scrollTop + el.clientHeight >= el.scrollHeight - 60;
  userScrolledUp = !atBottom;
});

function renderStatusBar(state) {
  const sess = state.session || {};
  document.getElementById('project').textContent = sess.project || '';

  const ctxEl = document.getElementById('contextPct');
  const ctxBtn = document.getElementById('contextBtn');
  const pct = sess.context_pct;
  if (pct !== undefined && pct !== null) {
    ctxEl.textContent = pct + '%';
    ctxBtn.dataset.level = pct >= 85 ? 'critical' : pct >= 70 ? 'low' : '';
  } else if (sess.project) {
    ctxEl.textContent = '0%';
    ctxBtn.dataset.level = '';
  } else {
    ctxEl.textContent = '';
    ctxBtn.dataset.level = '';
  }

  // Connection state
  const connected = state.connection !== 'disconnected';
  document.body.dataset.connection = connected ? 'connected' : 'disconnected';
  document.getElementById('switcherConnectionDot').dataset.state = connected ? 'connected' : 'disconnected';

  // Busy state â€” used by send button and activity chips
  const busy = connected && state.status === 'working';
  document.body.dataset.busy = busy;

  updateSendButton();
}

function renderSwitcher(state) {
  const switcher = document.getElementById('switcher');
  const list = document.getElementById('switcherList');

  const backdrop = document.getElementById('switcherBackdrop');
  if (!state.switcher || !switcherOpen) {
    switcher.dataset.open = 'false';
    backdrop.dataset.open = 'false';
    return;
  }

  backdrop.dataset.open = 'true';
  switcher.dataset.open = 'true';
  document.body.dataset.switcherOpen = '';
  list.innerHTML = '';

  const currentId = state.session ? state.session.id : null;
  const sessions = state.switcher.sessions || [];
  const filter = document.getElementById('switcherSearch').value.trim().toLowerCase();

  // Group: current first, then Now (active+paused), Previous (closed with history), fresh hidden
  const groups = { now: [], previous: [] };
  const freshPool = [];
  let top = null; // current session or most recently ended

  for (const s of sessions) {
    if (filter && !s.project.toLowerCase().includes(filter)) continue;
    if (s.project === sseCurrentFolder) { top = s; continue; }
    if (s.status === 'ended' && !top) { top = s; continue; }
    if (s.status === 'now') groups.now.push(s);
    else if (s.status === 'previous' && s.humanSessionCount > 0) groups.previous.push(s);
    else freshPool.push(s);
  }

  function timeAgo(iso) {
    if (!iso) return '';
    const mins = Math.floor((Date.now() - new Date(iso)) / 60000);
    if (mins < 0 || mins > 525600) return ''; // negative or >1 year = bad data
    if (mins < 1) return 'now';
    if (mins < 60) return mins + 'm';
    const hrs = Math.floor(mins / 60);
    if (hrs < 24) return hrs + 'h';
    return Math.floor(hrs / 24) + 'd';
  }

  function shortModel(model) {
    if (!model) return '';
    return model.replace('claude-', '').replace(/-\d+$/, '');
  }

  function makeItem(s, isCurrent) {
    const pct = s.context_pct;
    const level = pct >= 85 ? 'critical' : pct >= 70 ? 'low' : '';
    const hasSessions = s.sessions && s.sessions.length > 1;
    const isExpanded = switcherExpandedFolder === s.project;
    const item = document.createElement('div');
    item.className = 'switcher-item';
    item.dataset.status = s.backendState || s.status;
    if (isCurrent) item.dataset.current = 'true';

    // Main row: body (clickable â†’ connect) + chevron (clickable â†’ expand)
    const row = document.createElement('div');
    row.className = 'switcher-item-row';

    const body = document.createElement('div');
    body.className = 'switcher-item-body';
    body.innerHTML = `
      <span class="switcher-dot" data-status="${s.backendState || s.status}"></span>
      <div class="switcher-info">
        <div class="switcher-project">${esc(s.project)}</div>
        <div class="switcher-last-msg">${esc(s.last_message || '')}</div>
      </div>
      <div class="switcher-meta">
        <div class="switcher-context" data-level="${level}">${pct ? pct + '%' : ''}</div>
        <div class="switcher-time">${timeAgo(s.updated)}</div>
      </div>
    `;
    body.addEventListener('click', () => {
      if (bridgeUrl) {
        sseConnectFolder({ name: s.project, path: s.id });
        closeSwitcher();
      }
    });
    row.appendChild(body);

    if (hasSessions) {
      const humanCount = s.sessions.filter(sess => sess.humanInteraction !== false).length;
      const countBadge = document.createElement('span');
      countBadge.className = 'switcher-session-count';
      countBadge.textContent = humanCount;
      row.appendChild(countBadge);

      const chevron = document.createElement('div');
      chevron.className = 'switcher-chevron';
      chevron.dataset.expanded = isExpanded ? 'true' : 'false';
      chevron.textContent = '\u203A'; // â€º
      chevron.addEventListener('click', (e) => {
        e.stopPropagation();
        switcherExpandedFolder = isExpanded ? null : s.project;
        renderSwitcher(state);
      });
      row.appendChild(chevron);
    }

    item.appendChild(row);

    // Expanded session list
    if (hasSessions && isExpanded) {
      const sessionsDiv = document.createElement('div');
      sessionsDiv.className = 'switcher-sessions';

      // New Session button â€” top of list so you don't scroll through old sessions
      const newRow = document.createElement('div');
      newRow.className = 'switcher-new-session';
      newRow.innerHTML = '+ New Session';
      newRow.addEventListener('click', (e) => {
        e.stopPropagation();
        sseConnectFolder({ name: s.project, path: s.id }, 'new');
        closeSwitcher();
      });
      sessionsDiv.appendChild(newRow);

      // Filter to human-interactive sessions only (hide subagent spam)
      const humanSessions = s.sessions.filter(sess => sess.humanInteraction !== false);
      const hiddenCount = s.sessions.length - humanSessions.length;

      for (const sess of humanSessions) {
        const sessionPct = sess.contextPct;
        const sessionLevel = sessionPct >= 85 ? 'critical' : sessionPct >= 70 ? 'low' : '';
        const sessionRow = document.createElement('div');
        sessionRow.className = 'switcher-session-row';
        sessionRow.innerHTML = `
          <span class="switcher-dot" data-status="${sess.closed ? 'closed' : 'paused'}"></span>
          <span class="switcher-session-id">${esc(sess.id.slice(0, 8))}</span>
          <span class="switcher-session-model">${esc(shortModel(sess.model))}</span>
          <span class="switcher-context" data-level="${sessionLevel}">${sessionPct ? sessionPct + '%' : ''}</span>
          <span class="switcher-time">${timeAgo(sess.lastActive)}</span>
        `;
        sessionRow.addEventListener('click', (e) => {
          e.stopPropagation();
          sseConnectFolder({ name: s.project, path: s.id }, sess.id);
          closeSwitcher();
        });
        sessionsDiv.appendChild(sessionRow);
      }

      if (hiddenCount > 0) {
        const hidden = document.createElement('div');
        hidden.style.cssText = 'font-size: 0.65rem; color: var(--text-dim); padding: 4px 10px;';
        hidden.textContent = `${hiddenCount} subagent session${hiddenCount > 1 ? 's' : ''} hidden`;
        sessionsDiv.appendChild(hidden);
      }

      item.appendChild(sessionsDiv);
    }

    return item;
  }

  if (top) list.appendChild(makeItem(top, true));

  if (groups.now.length) {
    const label = document.createElement('div');
    label.className = 'switcher-section';
    label.textContent = 'Now';
    list.appendChild(label);
    for (const s of groups.now) list.appendChild(makeItem(s, false));
  }

  if (groups.previous.length) {
    const label = document.createElement('div');
    label.className = 'switcher-section';
    label.textContent = 'Previous';
    list.appendChild(label);
    for (const s of groups.previous) list.appendChild(makeItem(s, false));
  }

  // Fresh pool: only show when filtering or when nothing else exists
  const showFresh = freshPool.length && (filter || (!groups.now.length && !groups.previous.length && !top));
  if (showFresh) {
    const label = document.createElement('div');
    label.className = 'switcher-section';
    label.textContent = filter ? 'Other' : 'All Projects';
    list.appendChild(label);
    for (const s of freshPool) list.appendChild(makeItem(s, false));
  }
}

// Bridge mode renders via its own event handlers â€” no render() call needed.

function closeSwitcher() {
  switcherOpen = false;
  document.getElementById('switcher').dataset.open = 'false';
  document.getElementById('switcherBackdrop').dataset.open = 'false';
  document.getElementById('switcherSearch').value = '';
  delete document.body.dataset.switcherOpen;
}

// Switcher: open/close uses client-side state, search re-filters without refetching
document.getElementById('switcherClose').addEventListener('click', closeSwitcher);
document.getElementById('switcherBackdrop').addEventListener('click', closeSwitcher);

// Swipe-down-to-dismiss on switcher (handle + header area)
{
  const switcherEl = document.getElementById('switcher');
  let swipeStartY = null;
  let swipeStartTranslate = 0;
  const handleEl = switcherEl.querySelector('.switcher-handle');
  const headerEl = switcherEl.querySelector('.switcher-header');

  // Tap handle to dismiss
  handleEl.addEventListener('click', closeSwitcher);

  // Swipe from handle or header area
  for (const el of [handleEl, headerEl]) {
    el.addEventListener('touchstart', (e) => {
      swipeStartY = e.touches[0].clientY;
      swipeStartTranslate = 0;
      switcherEl.style.transition = 'none';
    }, { passive: true });

    el.addEventListener('touchmove', (e) => {
      if (swipeStartY === null) return;
      const dy = e.touches[0].clientY - swipeStartY;
      if (dy > 0) {
        swipeStartTranslate = dy;
        switcherEl.style.transform = `translateY(${dy}px)`;
      }
    }, { passive: true });

    el.addEventListener('touchend', () => {
      switcherEl.style.transition = '';
      if (swipeStartTranslate > 80) {
        // Animate to bottom, then close state after transition
        switcherEl.style.transform = 'translateY(100%)';
        closeSwitcher();
        setTimeout(() => { switcherEl.style.transform = ''; }, 300);
      } else {
        switcherEl.style.transform = '';
      }
      swipeStartY = null;
    });
  }

  // Tap empty space below list items dismisses (the switcher itself, not just backdrop)
  document.getElementById('switcherList').addEventListener('click', (e) => {
    if (e.target === e.currentTarget) closeSwitcher();
  });
}

document.getElementById('switcherSearch').addEventListener('input', () => {
  if (cachedState) renderSwitcher(cachedState);
});

// Folder lozenge: tap opens session switcher
document.getElementById('folderBtn').addEventListener('click', () => {
  switcherOpen = true;
  switcherExpandedFolder = null;
  if (bridgeUrl) {
    fetch(bridgeUrl + '/folders')
      .then(r => r.json())
      .then(d => { if (d.folders) handleSSEFolders(d.folders); })
      .catch(() => {});
  }
  if (cachedState) renderSwitcher(cachedState);
});

// Context lozenge: tap when amber/red offers exit, long-press always offers exit
{
  const contextBtn = document.getElementById('contextBtn');
  let longPressTimer = null;
  let didLongPress = false;
  contextBtn.addEventListener('pointerdown', () => {
    didLongPress = false;
    longPressTimer = setTimeout(() => {
      didLongPress = true;
      if (sseCurrentFolder && confirm('End this session and return to the lobby?')) {
        exitSession();
      }
    }, 800);
  });
  contextBtn.addEventListener('pointerup', () => {
    clearTimeout(longPressTimer);
    if (didLongPress) return;
    const level = contextBtn.dataset.level;
    if ((level === 'low' || level === 'critical') && sseCurrentFolder) {
      if (confirm('Context is running high. End this session and start fresh?')) {
        exitSession();
      }
    }
  });
  contextBtn.addEventListener('pointercancel', () => clearTimeout(longPressTimer));
}

// Auto-grow textarea: grows upward because flex layout shrinks messages area
const ta = document.querySelector('.input-field');
const msgEl = document.getElementById('messages');
const sendBtn = document.getElementById('sendBtn');

ta.addEventListener('input', () => {
  ta.style.height = 'auto';
  ta.style.height = Math.min(ta.scrollHeight, 120) + 'px';
  updateSendButton();
});

// Tapping input resets scroll â€” user wants to see latest to compose a reply
ta.addEventListener('focus', () => {
  userScrolledUp = false;
  msgEl.scrollTop = msgEl.scrollHeight;
});

// Enter = newline. Shift+Enter or Cmd/Ctrl+Enter = submit.
ta.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && (e.shiftKey || e.metaKey || e.ctrlKey)) {
    e.preventDefault();
    sendBtn.click();
  }
});

// Update send button state based on current text and connection/busy state
function updateSendButton() {
  const hasText = ta.value.trim().length > 0;
  const hasDeposits = stagedDeposits.length > 0;
  const hasContent = hasText || hasDeposits;
  const isDisconnected = document.body.dataset.connection === 'disconnected';
  const isBusy = document.body.dataset.busy === 'true';

  const isLive = !!bridgeUrl;
  if (isDisconnected && !isLive) {
    // File mode disconnected â€” disable send
    sendBtn.dataset.stop = 'false';
    sendBtn.dataset.active = 'false';
    sendBtn.innerHTML = '&#x2191;';
  } else if (isDisconnected && isLive) {
    // Live mode disconnected â€” allow send (queues as pending in WS, disabled in SSE)
    sendBtn.dataset.stop = 'false';
    sendBtn.dataset.active = hasContent ? 'true' : 'false';
    sendBtn.innerHTML = '&#x2191;';
  } else if (isBusy && !hasContent) {
    sendBtn.dataset.stop = 'true';
    delete sendBtn.dataset.active;
    sendBtn.innerHTML = '&#x25A0;'; // stop
  } else {
    sendBtn.dataset.stop = 'false';
    sendBtn.dataset.active = hasContent ? 'true' : 'false';
    sendBtn.innerHTML = '&#x2191;'; // send
  }
}

// Undo state â€” tracks the last sent message so it can be recalled
let undoTimer = null;
let undoEl = null;

// Staged deposits â€” files deposited on disk but not yet sent as prompt
let stagedDeposits = [];

function clearUndo() {
  if (undoTimer) clearTimeout(undoTimer);
  if (undoEl) {
    undoEl.dataset.fading = 'true';
    setTimeout(() => undoEl?.remove(), 300);
  }
  undoTimer = null;
  undoEl = null;
}

// Send button tap
sendBtn.addEventListener('click', () => {
  // Request notification permission on first user gesture
  if (!pushPermissionGranted && 'Notification' in window && Notification.permission === 'default') {
    pushRequestPermission();
  }

  const isDisconnected = document.body.dataset.connection === 'disconnected';
  const isLive = !!bridgeUrl;
  if (isDisconnected && !isLive) return;

  const isBusy = document.body.dataset.busy === 'true';
  const hasText = ta.value.trim().length > 0;
  const hasDeposits = stagedDeposits.length > 0;
  const hasContent = hasText || hasDeposits;

  if (isBusy && !hasContent) {
    // Stop â€” abort Claude's current turn
    if (bridgeUrl && sseCurrentFolder) {
      ssePostAbort(sseCurrentFolder);
    }
  } else if (hasContent) {
    // Clear any previous undo
    clearUndo();

    // Compose prompt: deposit notes first, then user text
    const parts = [];
    stagedDeposits.forEach(dep => {
      parts.push(buildDepositNoteClient(dep.folder, dep.manifest));
    });
    const userText = ta.value.trim();
    if (userText) parts.push(userText);
    const text = parts.join('\n\n');

    const msgId = 'msg-' + Date.now() + '-' + Math.random().toString(36).slice(2, 6);

    // Add message to DOM immediately as pending
    const bubble = document.createElement('div');
    bubble.className = 'msg-user';
    let bubbleHTML = '';
    if (hasDeposits) {
      const fileRefs = stagedDeposits.flatMap(dep =>
        dep.manifest.files.map(f => f.deposited_as)
      );
      bubbleHTML += `<div class="msg-files">\u{1F4CE} ${fileRefs.join(', ')}</div>`;
    }
    if (userText) bubbleHTML += marked.parseInline(userText);
    bubble.innerHTML = bubbleHTML;
    bubble.dataset.msgId = msgId;
    bubble.dataset.pending = 'true';
    msgEl.appendChild(bubble);

    // Also add to liveState so re-renders preserve it
    if (bridgeUrl) {
      liveState.messages.push({
        role: 'user', content: text, _msgId: msgId,
        pending: true, queued: false,
      });
    }

    // Send via SSE bridge â€” transition pending â†’ queued/delivered on response
    if (bridgeUrl && sseCurrentFolder) {
      ssePostPrompt(sseCurrentFolder, text).then(result => {
        const msg = liveState.messages.find(m => m._msgId === msgId);
        if (!msg) return;
        msg.pending = false;
        if (result.queued) {
          msg.queued = true;
          bubble.dataset.pending = 'false';
          bubble.dataset.queued = 'true';
        } else if (result.delivered) {
          // Delivered immediately â€” remove pending styling
          msg.queued = false;
          delete bubble.dataset.pending;
          delete bubble.dataset.queued;
        }
      });
    }

    // Undo button â€” available briefly after send
    {
      const undo = document.createElement('div');
      undo.className = 'msg-undo';
      undo.dataset.msgId = msgId;
      undo.innerHTML = '<button>undo</button>';
      msgEl.appendChild(undo);
      undoEl = undo;

      // Capture state for undo restore
      const savedText = ta.value.trim();
      const savedDeposits = [...stagedDeposits];

      undo.querySelector('button').addEventListener('click', () => {
        // Remove from liveState
        const li = liveState.messages.findIndex(m => m._msgId === msgId);
        if (li !== -1) liveState.messages.splice(li, 1);
        // Remove from DOM
        bubble.remove();
        undo.remove();
        undoEl = null;
        if (undoTimer) clearTimeout(undoTimer);
        undoTimer = null;
        ta.value = savedText;
        stagedDeposits = savedDeposits;
        renderStagedDeposits();
        ta.style.height = 'auto';
        ta.style.height = Math.min(ta.scrollHeight, 120) + 'px';
        ta.focus();
        updateSendButton();
      });

      // No timer â€” undo stays until message is flushed
    }

    // Clear staging
    stagedDeposits = [];
    renderStagedDeposits();

    // Scroll to bottom and reset scroll tracking
    userScrolledUp = false;
    msgEl.scrollTop = msgEl.scrollHeight;

    // Clear textarea
    ta.value = '';
    ta.style.height = 'auto';
    updateSendButton();
  }
});

// --- Slash command sheet ---
const slashSheet = document.getElementById('slashSheet');
const slashList = document.getElementById('slashList');
const slashBtn = document.getElementById('slashBtn');

const LOCAL_SLASH_COMMANDS = [
  { name: 'context', description: 'Show context window usage', local: true },
  { name: 'cost', description: 'Show session cost', local: true },
  { name: 'compact', description: 'Compact conversation history', local: true },
  { name: 'abort', description: 'Kill hung Claude process', local: true },
  { name: 'exit', description: 'End session and return to lobby', local: true },
];

function openSlashSheet() {
  const cmds = liveState.slashCommands?.length ? liveState.slashCommands : LOCAL_SLASH_COMMANDS;
  if (!cmds.length) return;

  slashList.innerHTML = '';
  for (const cmd of cmds) {
    const row = document.createElement('div');
    row.className = 'slash-cmd';

    const nameEl = document.createElement('span');
    nameEl.className = 'slash-cmd-name';
    nameEl.textContent = cmd.name;
    row.appendChild(nameEl);

    if (cmd.description) {
      const descEl = document.createElement('span');
      descEl.className = 'slash-cmd-desc';
      descEl.textContent = cmd.description;
      row.appendChild(descEl);
    }
    if (cmd.local) {
      const badge = document.createElement('span');
      badge.className = 'slash-cmd-local';
      badge.textContent = 'local';
      row.appendChild(badge);
    }

    row.addEventListener('click', () => {
      slashSheet.classList.remove('open');
      // /exit is handled client-side â€” triggers exitSession with confirmation
      if (cmd.name === 'exit') {
        if (sseCurrentFolder && confirm('End this session and return to the lobby?')) {
          exitSession();
        }
        return;
      }
      // /abort kills the CC process â€” emergency escape for hung sessions
      if (cmd.name === 'abort') {
        if (sseCurrentFolder) {
          ssePostAbort(sseCurrentFolder);
        }
        return;
      }
      ta.value = '/' + cmd.name;
      ta.style.height = 'auto';
      ta.style.height = Math.min(ta.scrollHeight, 120) + 'px';
      updateSendButton();
      // Local commands auto-send â€” they're instant, no reason to pause
      if (cmd.local) {
        sendBtn.click();
      } else {
        ta.focus();
      }
    });
    slashList.appendChild(row);
  }
  slashSheet.classList.add('open');
}

slashBtn.addEventListener('click', openSlashSheet);

// Close on backdrop tap
slashSheet.addEventListener('click', (e) => {
  if (e.target === slashSheet) slashSheet.classList.remove('open');
});

// === File upload ===
const fileInput = document.createElement('input');
fileInput.type = 'file';
fileInput.accept = 'image/*,.txt,.md,.json,.csv,.pdf,.doc,.docx';
fileInput.multiple = true;
fileInput.style.display = 'none';
document.body.appendChild(fileInput);

// Replicate server/upload.ts:buildDepositNote exactly â€” if this drifts,
// staged vs non-staged uploads produce different prompts for CC.
function buildDepositNoteClient(folder, manifest) {
  const listing = manifest.files
    .map(f => `  - ${f.deposited_as} (${f.mime_type}, ${f.size_bytes} bytes)`)
    .join('\n');
  const warningLines = manifest.warnings.length > 0
    ? '\n\n\u26A0\uFE0F ' + manifest.warnings.join('\n\u26A0\uFE0F ')
    : '';
  return `[gu\u00E9ridon:upload] Files deposited at ${folder}/\n\n${listing}${warningLines}\n\nmanifest.json has full metadata. Read the files if relevant to our conversation.`;
}

function showStagedError(msg) {
  const container = document.getElementById('stagedDeposits');
  const el = document.createElement('div');
  el.className = 'staged-error';
  el.textContent = msg;
  container.appendChild(el);
  setTimeout(() => el.remove(), 3000);
}

function renderStagedDeposits() {
  const container = document.getElementById('stagedDeposits');
  const errors = [...container.querySelectorAll('.staged-error')];
  container.innerHTML = '';
  errors.forEach(e => container.appendChild(e));

  stagedDeposits.forEach((dep, i) => {
    const pill = document.createElement('span');
    pill.className = 'staged-pill';
    const files = dep.manifest.files;
    const label = files.length === 1
      ? files[0].deposited_as
      : `${files[0].deposited_as} +${files.length - 1}`;
    pill.innerHTML = `<span class="staged-name">${label}</span><button class="staged-x" aria-label="Remove">\u00D7</button>`;
    pill.querySelector('.staged-x').addEventListener('click', () => {
      stagedDeposits.splice(i, 1);
      renderStagedDeposits();
      updateSendButton();
    });
    container.appendChild(pill);
  });
}

function uploadFiles(files) {
  if (!files.length) return;
  if (!sseCurrentFolder || !bridgeUrl) return;
  const fileBtn = document.getElementById('fileBtn');
  const targetFolder = sseCurrentFolder;
  const form = new FormData();
  for (const f of files) form.append('file', f);

  fileBtn.classList.add('uploading');
  fetch(`${bridgeUrl}/upload/${encodeURIComponent(targetFolder)}?stage=true`, {
    method: 'POST',
    body: form,
  })
    .then(r => r.json())
    .then(data => {
      if (data.error) {
        showStagedError(data.error);
        return;
      }
      if (sseCurrentFolder !== targetFolder) return;
      stagedDeposits.push({ folder: data.folder, manifest: data.manifest });
      renderStagedDeposits();
      updateSendButton();
    })
    .catch(() => showStagedError('Upload failed'))
    .finally(() => fileBtn.classList.remove('uploading'));
}

document.getElementById('fileBtn').addEventListener('click', () => {
  fileInput.click();
});

fileInput.addEventListener('change', () => {
  uploadFiles(fileInput.files);
  fileInput.value = '';
});

// Drag and drop on message area
msgEl.addEventListener('dragover', (e) => e.preventDefault());
msgEl.addEventListener('drop', (e) => {
  e.preventDefault();
  uploadFiles(e.dataTransfer.files);
});
</script>
</body>
</html>
