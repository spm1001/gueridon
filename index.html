<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>GuÃ©ridon</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/icon-192.svg" type="image/svg+xml">
<meta name="theme-color" content="#1a1a1a">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #1a1a1a;
    --surface: #242424;
    --surface-raised: #2a2a2a;
    --border: #333;
    --text: #e8e8e8;
    --text-dim: #777;
    --text-mid: #aaa;
    --accent: #d97757;
    --accent-dim: #B85A35;
    --green: #788c5d;
    --amber: #fbbf24;
    --blue: #6a9bcc;
    --red: #CE3931;
    --radius: 10px;
    --font: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    --mono: 'SF Mono', Menlo, Consolas, monospace;
    --safe-top: env(safe-area-inset-top, 0px);
    --safe-bottom: env(safe-area-inset-bottom, 0px);
  }

  html { font-size: 15px; overflow-x: hidden; }

  body {
    font-family: var(--font);
    background: var(--bg);
    color: var(--text);
    line-height: 1.5;
    height: 100dvh;
    display: flex;
    flex-direction: column;
    -webkit-font-smoothing: antialiased;
  }

  /* === Messages === */
  .messages {
    flex: 1;
    overflow-y: auto;
    padding: calc(var(--safe-top) + 12px) 14px 16px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .messages > * { flex-shrink: 0; }

  /* Synthetic system chip â€” centred, dim, informational */
  .msg-system {
    align-self: center;
    font-size: 0.75rem;
    color: var(--text-dim);
    font-style: italic;
    padding: 4px 12px;
    max-width: 85%;
  }

  /* User bubble â€” cool blue-grey (scheme A) */
  .msg-user {
    align-self: flex-end;
    max-width: 85%;
    background: #2a3a4a;
    color: #d4e4f4;
    padding: 9px 14px;
    border-radius: 18px 18px 4px 18px;
    font-size: 0.93rem;
    line-height: 1.4;
  }

  /* Assistant text â€” brand orange (scheme A) */
  .msg-assistant {
    align-self: flex-start;
    max-width: 92%;
    font-size: 0.93rem;
    padding: 2px 0;
    color: var(--accent);
    line-height: 1.5;
  }

  /* Markdown in assistant messages */
  .msg-assistant p { margin-bottom: 8px; }
  .msg-assistant p:last-child { margin-bottom: 0; }
  .msg-assistant strong { font-weight: 600; }
  .msg-assistant em { font-style: italic; }
  .msg-assistant del { text-decoration: line-through; color: var(--text-dim); }
  .msg-assistant a { color: var(--blue); text-decoration: underline; }

  .msg-assistant h1, .msg-assistant h2, .msg-assistant h3,
  .msg-assistant h4, .msg-assistant h5, .msg-assistant h6 {
    font-weight: 600;
    margin: 12px 0 4px;
  }
  .msg-assistant h1 { font-size: 1.25rem; }
  .msg-assistant h2 { font-size: 1.12rem; }
  .msg-assistant h3 { font-size: 1.0rem; }
  .msg-assistant h4, .msg-assistant h5, .msg-assistant h6 { font-size: 0.93rem; color: var(--text-mid); }

  .msg-assistant .task-list { list-style: none; margin-left: 4px; }
  .msg-assistant .task-list li::before { content: none; }
  .msg-assistant .task-checkbox { margin-right: 6px; }

  .msg-assistant code {
    font-family: var(--mono);
    font-size: 0.82rem;
    background: var(--surface-raised);
    padding: 1px 5px;
    border-radius: 4px;
  }

  .msg-assistant pre {
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 10px 12px;
    margin: 8px 0;
    overflow-x: auto;
    font-size: 0.78rem;
    line-height: 1.4;
    color: var(--text-mid);
  }

  .msg-assistant pre code {
    background: none;
    padding: 0;
    border-radius: 0;
    font-size: inherit;
  }

  .msg-assistant ul, .msg-assistant ol {
    margin: 4px 0 8px 20px;
  }

  .msg-assistant li { margin-bottom: 2px; }

  .msg-assistant table {
    border-collapse: collapse;
    margin: 8px 0;
    font-size: 0.82rem;
    width: 100%;
    color: var(--text-mid);
  }

  .msg-assistant th, .msg-assistant td {
    border: 1px solid var(--border);
    padding: 4px 8px;
    text-align: left;
  }

  .msg-assistant th {
    background: var(--surface-raised);
    font-weight: 600;
  }

  /* === Tool calls â€” pill chips === */
  .chip-grid {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    align-self: stretch;
  }

  .chip {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 4px 10px;
    display: inline-flex;
    align-items: center;
    gap: 4px;
    font-size: 0.65rem;
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
    transition: border-color 0.15s;
  }

  .chip .c-status { font-size: 0.45rem; flex-shrink: 0; }
  .chip .c-status.done { color: var(--green); }
  .chip .c-status.err { color: var(--red); }
  .chip .c-status.run { color: var(--amber); }
  .chip .c-name { font-family: var(--mono); color: var(--text-dim); white-space: nowrap; }
  .chip .c-path {
    font-family: var(--mono);
    font-size: 0.58rem;
    color: var(--text-dim);
    opacity: 0.4;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    max-width: 100px;
  }

  .chip.error { border-color: var(--red); }

  /* Running chip â€” pulsing amber border */
  .chip.running {
    border-color: var(--amber);
    animation: pulse-amber 1.5s ease-in-out infinite;
  }
  @keyframes pulse-amber {
    0%, 100% { border-color: var(--border); }
    50% { border-color: var(--amber); }
  }

  /* Expanded chip â€” full width with detail pane */
  .chip.expanded {
    flex-basis: 100%;
    flex-direction: column;
    align-items: flex-start;
    border-radius: 8px;
    padding: 6px 10px;
    gap: 4px;
  }

  .chip .c-detail {
    display: none;
    font-family: var(--mono);
    font-size: 0.6rem;
    color: var(--text-dim);
    white-space: pre-wrap;
    max-height: 150px;
    overflow-y: auto;
    width: 100%;
    padding-top: 4px;
    border-top: 1px solid var(--border);
  }

  .chip.expanded .c-detail { display: block; }

  /* === Local command output (collapsible) === */
  .local-cmd {
    align-self: flex-start;
    max-width: 92%;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    font-size: 0.82rem;
    margin: 2px 0;
  }

  .local-cmd-header {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 10px;
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
    min-height: 32px;
  }

  .local-cmd-header .tool-chevron {
    font-size: 0.68rem;
    color: var(--text-dim);
    flex-shrink: 0;
    transition: transform 0.15s;
  }

  .local-cmd-summary {
    color: #ddd;
    font-size: 0.82rem;
  }

  .local-cmd-body {
    display: none;
    padding: 8px 10px;
    font-size: 0.8rem;
    color: #bbb;
    border-top: 1px solid var(--border);
  }

  .local-cmd[data-expanded="true"] .local-cmd-body {
    display: block;
  }

  .local-cmd[data-expanded="true"] .tool-chevron {
    transform: rotate(90deg);
  }

  /* Tables inside local command output */
  .local-cmd-body table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.75rem;
    margin: 6px 0;
  }

  .local-cmd-body th, .local-cmd-body td {
    padding: 3px 6px;
    border-bottom: 1px solid var(--border);
    text-align: left;
  }

  .local-cmd-body th {
    color: var(--text-dim);
    font-weight: 600;
  }

  /* Stop button font size */
  .btn-send[data-stop="true"] {
    font-size: 0.7rem;
  }

  /* === Error toast === */
  .error-toast {
    margin: 0 14px 8px;
    background: rgba(248, 113, 113, 0.15);
    border: 1px solid var(--red);
    border-radius: 8px;
    padding: 8px 12px;
    font-size: 0.82rem;
    color: var(--red);
    display: none;
  }

  .error-toast.visible { display: block; }

  /* === Input area === */
  .input-area {
    flex-shrink: 0;
    background: var(--surface);
    border-top: 1px solid var(--border);
    padding: 8px 14px calc(var(--safe-bottom) + 4px);
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  /* In standalone PWA mode, iOS reports viewport height shorter than the
     actual screen (793px vs 852px on iPhone 14 Pro). CSS viewport units
     and position:fixed are both capped at this wrong value. JS sets
     html height to screen.height to fill the real screen. */
  @media (display-mode: standalone) {
    html {
      overflow: hidden;
    }
    .input-area {
      padding-bottom: max(env(safe-area-inset-bottom, 0px), 4px);
    }
    .input-area.keyboard-open {
      padding-bottom: 4px;
    }
  }

  .input-field {
    width: 100%;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 20px;
    padding: 9px 14px;
    color: var(--text);
    font-family: var(--font);
    font-size: 16px; /* Prevents Safari auto-zoom on focus */
    resize: none;
    outline: none;
    min-height: 38px;
    max-height: 120px;
    overflow-y: auto;
  }

  .input-field:focus { border-color: var(--accent-dim); }
  .input-field::placeholder { color: var(--text-dim); }

  /* Button bar below textarea */
  .btn-bar {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .btn-circle {
    width: 34px;
    height: 34px;
    border-radius: 50%;
    border: none;
    font-size: 1rem;
    font-weight: 600;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    cursor: pointer;
  }

  .btn-slash, .btn-file {
    background: transparent;
    border: 1px solid var(--border);
    color: var(--text-dim);
  }
  .btn-slash:active, .btn-file:active { background: var(--surface-raised); }

  .btn-send {
    background: var(--text-dim);
    color: var(--bg);
    font-size: 1.1rem;
  }
  .btn-send[data-active="true"] { background: var(--accent); }
  .btn-send[data-stop="true"] { background: var(--red); }

  .btn-lozenge {
    height: 34px;
    border-radius: 17px;
    border: 1px solid var(--border);
    background: transparent;
    color: var(--text-dim);
    font-family: var(--font);
    font-size: 0.72rem;
    padding: 0 12px;
    display: flex;
    align-items: center;
    gap: 4px;
    cursor: pointer;
    white-space: nowrap;
    overflow: hidden;
  }
  .btn-lozenge:active { background: var(--surface-raised); }
  .btn-lozenge.folder { flex: 1; min-width: 0; }
  .btn-lozenge .label { overflow: hidden; text-overflow: ellipsis; }
  .btn-lozenge .pct { font-family: var(--mono); font-size: 0.7rem; }
  .btn-lozenge[data-level="low"] { border-color: var(--amber); color: var(--amber); }
  .btn-lozenge[data-level="critical"] { border-color: var(--red); color: var(--red); }

  .push-denied {
    font-size: 0.65rem;
    display: none;
    cursor: pointer;
  }
  .push-denied.visible { display: inline; }

  /* Hide non-essential buttons until a folder is connected */
  .btn-slash, .btn-file { display: none; }
  .btn-slash.visible, .btn-file.visible { display: flex; }

  /* Slash command sheet */
  .slash-sheet-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.5);
    z-index: 100;
  }
  .slash-sheet-overlay.open { display: block; }

  .slash-sheet {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: var(--surface);
    border-radius: 14px 14px 0 0;
    max-height: 60vh;
    overflow-y: auto;
    padding: 12px 0 calc(var(--safe-bottom) + 12px);
  }
  .slash-sheet-handle {
    width: 36px;
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    margin: 0 auto 10px;
  }
  .slash-sheet-title {
    padding: 0 16px 8px;
    font-size: 0.8rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }
  .slash-cmd {
    display: flex;
    align-items: baseline;
    gap: 10px;
    padding: 11px 16px;
    cursor: pointer;
  }
  .slash-cmd:active { background: var(--surface-raised); }
  .slash-cmd-name {
    font-family: var(--mono);
    font-size: 0.9rem;
    color: var(--accent);
    white-space: nowrap;
  }
  .slash-cmd-desc {
    font-size: 0.8rem;
    color: var(--text-dim);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .slash-cmd-local {
    font-size: 0.65rem;
    color: var(--amber);
    background: rgba(245,158,11,0.15);
    padding: 1px 5px;
    border-radius: 3px;
    white-space: nowrap;
  }

  /* Disconnected state: desaturated + dimmed â€” clearly "wrong" like Mac deep-sleep resume */
  body[data-connection="disconnected"] .messages {
    opacity: 0.5;
    filter: grayscale(0.8);
  }

  body[data-connection="disconnected"] .input-field {
    opacity: 0.4;
    pointer-events: none;
  }

  body[data-connection="disconnected"] .btn-send {
    opacity: 0.3;
    pointer-events: none;
  }

  body[data-connection="disconnected"] .btn-slash,
  body[data-connection="disconnected"] .btn-file {
    opacity: 0.3;
    pointer-events: none;
  }

  /* Thinking chip â€” coral pulsing border */
  .chip.thinking {
    border-color: var(--accent);
    animation: pulse-coral 1.5s ease-in-out infinite;
    color: var(--accent);
  }
  .chip.thinking .c-name { color: var(--accent); }
  @keyframes pulse-coral {
    0%, 100% { border-color: var(--border); opacity: 0.5; }
    50% { border-color: var(--accent); opacity: 1; }
  }

  /* Completed thinking chip â€” static coral accent */
  .chip.thinking-done {
    border-color: var(--border);
    color: var(--accent);
  }
  .chip.thinking-done .c-name { color: var(--accent); }
  .chip.thinking-done .c-detail {
    color: var(--text-dim);
    line-height: 1.45;
  }

  /* Writing chip â€” green pulsing border */
  .chip.writing {
    border-color: var(--green);
    animation: pulse-green 1.5s ease-in-out infinite;
    color: var(--green);
  }
  .chip.writing .c-name { color: var(--green); }
  @keyframes pulse-green {
    0%, 100% { border-color: var(--border); opacity: 0.5; }
    50% { border-color: var(--green); opacity: 1; }
  }

  /* Queued message indicator â€” no opacity stacking, just a dashed border */
  .msg-user[data-queued="true"] {
    border: 1px dashed var(--accent-dim);
  }

  .msg-user[data-queued="true"]::after {
    content: 'queued';
    display: block;
    font-size: 0.65rem;
    color: var(--text-mid);
    text-align: right;
    margin-top: 2px;
  }

  .msg-user[data-pending="true"] {
    border: 1px dotted var(--text-dim);
  }

  .msg-user[data-pending="true"]::after {
    content: 'sendingâ€¦';
    display: block;
    font-size: 0.65rem;
    color: var(--text-dim);
    text-align: right;
    margin-top: 2px;
  }

  /* Undo send â€” tap target on a just-sent message */
  .msg-undo {
    display: flex;
    justify-content: flex-end;
    padding: 4px 0;
  }

  .msg-undo button {
    background: none;
    border: 1px solid var(--text-dim);
    border-radius: 12px;
    color: var(--text-dim);
    font-family: var(--font);
    font-size: 0.72rem;
    padding: 3px 10px;
    cursor: pointer;
  }

  .msg-undo button:active {
    background: var(--surface-raised);
  }

  .msg-undo[data-fading="true"] {
    animation: fadeOut 0.3s ease forwards;
  }

  @keyframes fadeOut {
    to { opacity: 0; height: 0; padding: 0; overflow: hidden; }
  }

  /* === Session switcher â€” bottom sheet === */
  .switcher-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.5);
    z-index: 99;
    display: none;
    touch-action: manipulation; /* Prevent iOS double-tap-to-zoom */
  }

  .switcher-backdrop[data-open="true"] {
    display: block;
  }

  .switcher {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    height: 82vh;
    background: var(--surface);
    border-radius: 14px 14px 0 0;
    z-index: 100;
    display: flex;
    flex-direction: column;
    transform: translateY(100%);
    visibility: hidden;
    transition: transform 0.25s ease, visibility 0s 0.25s;
    overscroll-behavior: none; /* Prevent pull-to-refresh hijacking */
    touch-action: pan-y; /* Allow scroll but prevent other gestures */
  }

  .switcher[data-open="true"] {
    transform: translateY(0) !important;
    visibility: visible;
    transition: transform 0.25s ease, visibility 0s;
  }

  .switcher-handle {
    width: 36px;
    height: 4px;
    background: var(--text-dim);
    border-radius: 2px;
    margin: 8px auto 4px;
    opacity: 0.4;
  }

  .switcher-header {
    padding: 12px 14px 8px;
    display: flex;
    align-items: center;
    gap: 10px;
    flex-shrink: 0;
  }

  .switcher-search {
    flex: 1;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 20px;
    padding: 9px 14px;
    color: var(--text);
    font-family: var(--font);
    font-size: 0.93rem;
    outline: none;
  }

  .switcher-search:focus { border-color: var(--accent-dim); }
  .switcher-search::placeholder { color: var(--text-dim); }

  .switcher-close {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--text-dim);
    font-size: 1.1rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
  }

  .switcher-list {
    flex: 1;
    overflow-y: auto;
    padding: 4px 14px 20px;
  }

  .switcher-item {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 0;
    padding: 12px 10px;
    border-bottom: 1px solid var(--border);
    cursor: pointer;
  }

  .switcher-item:active {
    background: var(--surface);
  }

  .switcher-item[data-current="true"] {
    background: var(--surface);
    border-radius: 8px;
    border-bottom-color: transparent;
    margin-bottom: 2px;
  }

  .switcher-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  .switcher-dot[data-status="active"] { background: var(--green); }
  .switcher-dot[data-status="dormant"] { background: var(--amber); opacity: 0.5; }
  .switcher-dot[data-status="old"] { background: var(--text-dim); opacity: 0.3; }

  .switcher-info {
    flex: 1;
    min-width: 0;
  }

  .switcher-project {
    font-weight: 600;
    font-size: 0.93rem;
  }

  .switcher-item[data-status="old"] .switcher-project {
    color: var(--text-dim);
  }

  .switcher-last-msg {
    color: var(--text-dim);
    font-size: 0.78rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .switcher-meta {
    text-align: right;
    flex-shrink: 0;
  }

  .switcher-context {
    font-family: var(--mono);
    font-size: 0.72rem;
    color: var(--text-dim);
  }

  .switcher-context[data-level="low"] { color: var(--amber); }
  .switcher-context[data-level="critical"] { color: var(--red); }

  .switcher-time {
    font-size: 0.68rem;
    color: var(--text-dim);
  }

  .switcher-section {
    font-size: 0.68rem;
    font-weight: 600;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    padding: 12px 10px 4px;
  }

  /* -- Session expansion within folder row -- */
  .switcher-item-row {
    display: flex;
    align-items: center;
    width: 100%;
    gap: 10px;
  }

  .switcher-item-body {
    flex: 1;
    display: flex;
    align-items: center;
    gap: 10px;
    min-width: 0;
    cursor: pointer;
  }

  .switcher-chevron {
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    cursor: pointer;
    color: var(--text-dim);
    font-size: 0.8rem;
    transition: transform 0.15s ease;
  }

  .switcher-chevron[data-expanded="true"] {
    transform: rotate(90deg);
  }

  .switcher-session-count {
    font-family: var(--mono);
    font-size: 0.65rem;
    color: var(--text-dim);
    background: var(--border);
    border-radius: 8px;
    padding: 1px 5px;
    flex-shrink: 0;
  }

  .switcher-sessions {
    width: 100%;
    padding-left: 28px;
    margin-top: 4px;
  }

  .switcher-session-row {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 10px;
    cursor: pointer;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  }

  .switcher-session-row:last-child {
    border-bottom: none;
  }

  .switcher-session-row:active {
    background: var(--surface);
  }

  .switcher-session-id {
    font-family: var(--mono);
    font-size: 0.72rem;
    color: var(--text-mid);
    flex: 1;
  }

  .switcher-session-model {
    font-family: var(--mono);
    font-size: 0.62rem;
    color: var(--text-dim);
  }

  .switcher-new-session {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 10px;
    cursor: pointer;
    color: var(--accent);
    font-size: 0.78rem;
  }

  .switcher-new-session:active {
    opacity: 0.7;
  }

  /* === Ask User overlay â€” bottom sheet === */
  .ask-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(2px);
    -webkit-backdrop-filter: blur(2px);
    z-index: 200;
    display: none;
    touch-action: manipulation;
  }
  .ask-backdrop[data-open="true"] { display: block; }

  .ask-sheet {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    max-height: 70vh;
    background: var(--surface);
    border-radius: 14px 14px 0 0;
    z-index: 201;
    display: flex;
    flex-direction: column;
    transform: translateY(100%);
    visibility: hidden;
    transition: transform 0.25s ease, visibility 0s 0.25s;
    padding-bottom: env(safe-area-inset-bottom, 0px);
    overscroll-behavior: none;
  }
  .ask-sheet[data-open="true"] {
    transform: translateY(0);
    visibility: visible;
    transition: transform 0.25s ease, visibility 0s;
  }

  .ask-handle {
    width: 36px;
    height: 4px;
    background: var(--text-dim);
    border-radius: 2px;
    margin: 8px auto 4px;
    opacity: 0.4;
  }

  .ask-question {
    padding: 8px 16px 4px;
    font-size: 0.85rem;
    color: var(--text);
    font-weight: 500;
  }

  .ask-header {
    padding: 0 16px;
    font-size: 0.65rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.04em;
  }

  .ask-options {
    padding: 8px 12px 12px;
    display: flex;
    flex-direction: column;
    gap: 6px;
    overflow-y: auto;
  }

  .ask-option {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 12px 14px;
    min-height: 44px;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 10px;
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
    transition: background 0.1s;
  }
  .ask-option:active { background: var(--surface-raised); }
  .ask-option[data-selected="true"] {
    border-color: var(--accent);
    background: var(--surface-raised);
  }

  .ask-option-label {
    font-size: 0.85rem;
    color: var(--text);
    font-weight: 500;
  }

  .ask-option-desc {
    font-size: 0.72rem;
    color: var(--text-dim);
    margin-top: 2px;
  }

  .ask-option-check {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    border: 2px solid var(--border);
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.7rem;
    color: transparent;
  }
  .ask-option[data-selected="true"] .ask-option-check {
    border-color: var(--accent);
    color: var(--accent);
  }

  .ask-confirm {
    margin: 4px 12px 8px;
    padding: 12px;
    min-height: 44px;
    background: var(--accent);
    color: var(--bg);
    border: none;
    border-radius: 10px;
    font-size: 0.85rem;
    font-weight: 600;
    cursor: pointer;
    display: none;
  }
  .ask-confirm[data-visible="true"] { display: block; }
  .ask-confirm:active { opacity: 0.8; }

  .ask-custom {
    padding: 8px 12px 12px;
    text-align: center;
    font-size: 0.72rem;
    color: var(--text-dim);
    cursor: pointer;
  }
</style>
</head>
<body>

  <div class="switcher-backdrop" id="switcherBackdrop"></div>
  <div class="switcher" id="switcher">
    <div class="switcher-handle"></div>
    <div class="switcher-header">
      <span class="status-connection" id="switcherConnectionDot"></span>
      <input class="switcher-search" id="switcherSearch" type="text" placeholder="Filter sessionsâ€¦">
      <button class="switcher-close" id="switcherClose" aria-label="Close">&#x2715;</button>
    </div>
    <div class="switcher-list" id="switcherList"></div>
  </div>

  <div class="ask-backdrop" id="askBackdrop"></div>
  <div class="ask-sheet" id="askSheet">
    <div class="ask-handle"></div>
    <div id="askContent"></div>
  </div>

  <div class="messages" id="messages"></div>

  <div id="errorToast" class="error-toast"></div>

  <div class="slash-sheet-overlay" id="slashSheet">
    <div class="slash-sheet">
      <div class="slash-sheet-handle"></div>
      <div class="slash-sheet-title">Commands</div>
      <div id="slashList"></div>
    </div>
  </div>

  <div class="input-area">
    <textarea class="input-field" placeholder="Message Claude..." rows="1"></textarea>
    <div class="btn-bar">
      <button class="btn-circle btn-file" aria-label="Attach" id="fileBtn">+</button>
      <button class="btn-circle btn-slash" aria-label="Commands" id="slashBtn">/</button>
      <button class="btn-lozenge folder" id="folderBtn"><span class="label" id="project"></span></button>
      <button class="btn-lozenge context" id="contextBtn"><span class="pct" id="contextPct"></span><span class="push-denied" id="pushDenied" title="Notifications blocked">ðŸ”‡</span></button>
      <button class="btn-circle btn-send" aria-label="Send" id="sendBtn">&#x2191;</button>
    </div>
  </div>

<script>
// === Client error reporting ===
// Captures unhandled errors and promise rejections, sends to bridge.
// Fire-and-forget â€” never blocks or throws.
{
  const reported = new Set();
  function reportError(message, stack) {
    const key = message + (stack || '');
    if (reported.has(key)) return;
    reported.add(key);
    setTimeout(() => reported.delete(key), 5000); // dedup window
    try {
      fetch('/client-error', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message, stack, userAgent: navigator.userAgent, url: location.href }),
      }).catch(() => {}); // swallow fetch failures
    } catch { /* swallow */ }
  }
  window.addEventListener('error', (e) => reportError(e.message, e.error?.stack));
  window.addEventListener('unhandledrejection', (e) => reportError(String(e.reason), e.reason?.stack));
}

let cachedState = null;
let switcherOpen = false;
let switcherExpandedFolder = null; // folder name currently expanded in switcher
let userScrolledUp = false; // true when user has scrolled away from bottom

// === Mode detection ===
const params = new URLSearchParams(location.search);
let bridgeUrl = params.get('bridge'); // Explicit bridge URL: ?bridge=http://kube:3001

// === iOS standalone viewport fix ===
// iOS reports viewport height shorter than the actual screen in standalone mode.
// CSS viewport units (dvh, vh) and position:fixed are all capped at this wrong value.
// Force html+body to screen.height which IS the real renderable area.
// iOS standalone: force full screen height, and resize when keyboard opens.
// Without this, iOS reports viewport height shorter than the actual screen (793px vs 852px)
// and the messages area extends behind the keyboard, blocking scroll-to-top.
{
  const isStandalone = window.matchMedia('(display-mode: standalone)').matches;
  if (isStandalone) {
    document.documentElement.style.height = screen.height + 'px';
    document.body.style.height = screen.height + 'px';
  }
  if (window.visualViewport) {
    const inputArea = document.querySelector('.input-area');
    const refHeight = window.visualViewport.height;
    window.visualViewport.addEventListener('resize', () => {
      const keyboardOpen = window.visualViewport.height < refHeight - 100;
      inputArea.classList.toggle('keyboard-open', keyboardOpen);
      if (isStandalone) {
        const h = (keyboardOpen ? window.visualViewport.height : screen.height) + 'px';
        document.documentElement.style.height = h;
        document.body.style.height = h;
        window.scrollTo(0, 0);
      }
    });
  }
}

// === Push notifications ===
let swRegistration = null;
let swReady = null;
let pushPermissionGranted = false;

// Register service worker immediately (needed for push + PWA install)
if ('serviceWorker' in navigator) {
  swReady = navigator.serviceWorker.register('/sw.js').then(
    (reg) => { swRegistration = reg; return reg; },
    (e) => { console.warn('[push] SW registration failed:', e); return null; },
  );
  // Listen for notification click deep-links from service worker
  navigator.serviceWorker.addEventListener('message', (ev) => {
    if (ev.data?.type === 'notificationClick' && ev.data.folder) {
      location.hash = ev.data.folder;
    }
  });
} else {
  swReady = Promise.resolve(null);
}

/** Request notification permission. Must be called from user gesture. */
async function pushRequestPermission() {
  if (!('Notification' in window)) return false;
  if (Notification.permission === 'granted') { pushPermissionGranted = true; return true; }
  if (Notification.permission === 'denied') {
    document.getElementById('pushDenied').classList.add('visible');
    return false;
  }
  const result = await Notification.requestPermission();
  pushPermissionGranted = result === 'granted';
  if (!pushPermissionGranted) {
    document.getElementById('pushDenied').classList.add('visible');
  }
  return pushPermissionGranted;
}

// Push denied indicator: tap shows instructions
document.getElementById('pushDenied').addEventListener('click', (e) => {
  e.stopPropagation();
  alert('Notifications are blocked.\n\nTo re-enable:\niOS: Settings â†’ Notifications â†’ Safari\nAndroid: Site settings â†’ Notifications');
});

/** Subscribe to push via bridge. Call after hello provides VAPID key. */
async function pushSubscribe(vapidPublicKey) {
  await swReady;
  if (!swRegistration || !vapidPublicKey || !('PushManager' in window)) return;
  try {
    let sub = await swRegistration.pushManager.getSubscription();
    if (!sub) {
      const padding = '='.repeat((4 - (vapidPublicKey.length % 4)) % 4);
      const b64 = (vapidPublicKey + padding).replace(/-/g, '+').replace(/_/g, '/');
      const raw = atob(b64);
      const key = new Uint8Array(raw.length);
      for (let i = 0; i < raw.length; i++) key[i] = raw.charCodeAt(i);
      sub = await swRegistration.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: key });
    }
    // POST subscription to bridge
    if (bridgeUrl) {
      await fetch(`${bridgeUrl}/push/subscribe`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(sub.toJSON()),
      });
      console.log('[push] Subscription sent to bridge');
    }
  } catch (e) {
    console.warn('[push] Subscription failed:', e);
  }
}

/** Show local notification (when page is unfocused and SW available). */
function pushNotify(body, opts = {}) {
  if (document.hasFocus()) return;
  if (!pushPermissionGranted && Notification.permission !== 'granted') return;
  const title = 'GuÃ©ridon';
  if (swRegistration) {
    swRegistration.showNotification(title, {
      body,
      icon: '/icon-192.svg',
      badge: '/icon-192.svg',
      tag: opts.tag || 'gueridon-default',
      renotify: true,
      vibrate: opts.vibrate || [200],
      data: { folder: opts.folder || '' },
    });
  } else {
    new Notification(title, { body, icon: '/icon-192.svg', tag: opts.tag || 'gueridon-default' });
  }
}

// === SSE bridge client ===
let sseSource = null;
let sseClientId = 'bb-' + Date.now().toString(36) + Math.random().toString(36).slice(2, 6);
let sseCurrentFolder = null; // folder name we're connected to
let sseWatchdog = null;
const SSE_WATCHDOG_MS = 65_000; // 60s silence = dead (pings every 30s + margin)

// Live state â€” shared between SSE and WS modes
let liveState = {
  session: {},
  messages: [],
  connection: 'disconnected',
  status: 'idle',
  error: null,
  switcher: null,
  _activity: null,
};

function sseConnect() {
  if (!bridgeUrl) return;
  if (sseSource) { sseSource.close(); sseSource = null; }

  const url = `${bridgeUrl}/events?clientId=${encodeURIComponent(sseClientId)}`;
  sseSource = new EventSource(url);

  sseSource.addEventListener('hello', (ev) => {
    const data = JSON.parse(ev.data);
    if (data.version !== 1) {
      console.error('[bb] protocol version mismatch, reloading');
      location.reload();
      return;
    }
    liveState.connection = 'connected';
    liveState.error = null;
    sseResetWatchdog();
    sseRender();

    // Subscribe to push if bridge provides VAPID key
    if (data.vapidPublicKey) {
      pushSubscribe(data.vapidPublicKey);
    }

    // Re-establish session from hash or previous state
    if (data.reconnect && sseCurrentFolder) {
      ssePostSession(sseCurrentFolder);
    } else if (location.hash.length > 1) {
      ssePostSession(location.hash.slice(1));
    }
  });

  sseSource.addEventListener('folders', (ev) => {
    const data = JSON.parse(ev.data);
    sseResetWatchdog();
    handleSSEFolders(data.folders || []);
  });

  sseSource.addEventListener('state', (ev) => {
    const data = JSON.parse(ev.data);
    sseResetWatchdog();
    // Discard events for wrong folder (data.folder is the routing key; data.session is the session object)
    if (sseCurrentFolder && data.folder && data.folder !== sseCurrentFolder) return;
    handleSSEState(data);
  });

  sseSource.addEventListener('delta', (ev) => {
    const data = JSON.parse(ev.data);
    sseResetWatchdog();
    if (sseCurrentFolder && data.folder && data.folder !== sseCurrentFolder) return;
    handleSSEDelta(data);
  });

  sseSource.addEventListener('ping', () => {
    sseResetWatchdog();
  });

  sseSource.onerror = () => {
    liveState.connection = 'disconnected';
    liveState._activity = null;
    sseRender();
    // EventSource auto-reconnects â€” no manual retry needed
  };

  sseSource.onopen = () => {
    // Fires on initial connect and each reconnect
    sseResetWatchdog();
  };
}

function sseResetWatchdog() {
  if (sseWatchdog) clearTimeout(sseWatchdog);
  sseWatchdog = setTimeout(() => {
    console.log('[bb] SSE watchdog: no events for 65s, reconnecting');
    if (sseSource) { sseSource.close(); sseSource = null; }
    liveState.connection = 'disconnected';
    sseRender();
    sseConnect();
  }, SSE_WATCHDOG_MS);
}

function mapFolderState(state) {
  if (state === 'active') return 'active';
  if (state === 'fresh' || state === 'idle') return 'dormant';
  return 'old';
}

function handleSSEFolders(folders) {
  liveState.switcher = {
    sessions: folders.map(f => ({
      id: f.path || f.name,
      project: f.name,
      status: mapFolderState(f.state),
      updated: f.lastActive,
      last_message: f.handoffPurpose || '',
      context_pct: f.contextPct || 0,
      sessions: f.sessions || [],
    })),
  };

  // Auto-connect: hash, first active, or open switcher
  if (!sseCurrentFolder) {
    let target = null;
    if (location.hash.length > 1) {
      const hashName = location.hash.slice(1);
      target = folders.find(f => f.name === hashName || f.path === hashName);
    }
    if (!target) target = folders.find(f => f.state === 'active');
    if (target) {
      sseConnectFolder(target);
    } else {
      switcherOpen = true;
    }
  }
  sseRender();
}

function handleSSEState(data) {
  // Bridge broadcasts: { session: folderName, ...getState() }
  // getState().session is {id, model, project, context_pct} â€” overwrites the string
  // (later properties win in spread). So data.session is the object.

  if (data.messages) liveState.messages = data.messages;
  if (data.session && typeof data.session === 'object') {
    liveState.session = { ...liveState.session, ...data.session };
  }
  if (data.status) liveState.status = data.status;
  if (data.error !== undefined) liveState.error = data.error;
  if (data.slashCommands !== undefined) liveState.slashCommands = data.slashCommands;
  if (data.status === 'idle') {
    liveState._activity = null;
    // Local notification when Claude finishes (page unfocused)
    const folder = sseCurrentFolder || '';
    pushNotify(`Claude finished in ${folder}`, {
      tag: `gueridon-done-${folder}`,
      folder,
    });
  }

  sseRender();
}

function handleSSEDelta(data) {
  switch (data.type) {
    case 'status':
      liveState.status = data.status;
      if (data.status === 'idle') liveState._activity = null;
      // Working status = CC ingested queued messages â€” clear queued/pending flags
      if (data.status === 'working') {
        for (const msg of liveState.messages) {
          if (msg.queued || msg.pending) {
            msg.queued = false;
            msg.pending = false;
          }
        }
      }
      break;

    case 'message_start':
      // New CC assistant turn â€” push a fresh skeleton so subsequent content/tool
      // deltas don't overwrite the previous turn's message.
      liveState.messages.push({ role: 'assistant', content: null });
      break;

    case 'activity':
      liveState._activity = data.activity;
      liveState.status = 'working';
      // Ensure an assistant message exists for incoming content/tool deltas
      ensureAssistantMessage();
      break;

    case 'content': {
      const msg = ensureAssistantMessage();
      msg.content = data.text;
      break;
    }

    case 'tool_start': {
      const msg = ensureAssistantMessage();
      if (!msg.tool_calls) msg.tool_calls = [];
      // Ensure we have an entry at this index
      while (msg.tool_calls.length <= data.index) {
        msg.tool_calls.push({ name: '', status: 'running', input: '', output: null, collapsed: true });
      }
      msg.tool_calls[data.index] = {
        name: data.name,
        status: 'running',
        input: data.input || '',
        output: null,
        collapsed: true,
      };
      break;
    }

    case 'tool_complete': {
      const last = liveState.messages[liveState.messages.length - 1];
      if (last?.tool_calls?.[data.index]) {
        last.tool_calls[data.index].status = data.status;
        if (data.output) last.tool_calls[data.index].output = data.output;
      }
      break;
    }

    case 'ask_user':
      showAskUserOverlay(data.questions, data.toolCallId);
      break;

    case 'thinking_content': {
      const msg = ensureAssistantMessage();
      msg.thinking = data.text;
      break;
    }

    case 'api_error':
      liveState.status = 'idle';
      liveState._activity = null;
      liveState.messages.push({ role: 'assistant', content: data.error });
      break;
  }
  sseRender();
}

/** Ensure the last message is an assistant message â€” create one if not. */
function ensureAssistantMessage() {
  const last = liveState.messages[liveState.messages.length - 1];
  if (last && last.role === 'assistant') return last;
  const msg = { role: 'assistant', content: null };
  liveState.messages.push(msg);
  return msg;
}

async function ssePostSession(folderName, sessionId) {
  try {
    const body = sessionId ? { sessionId } : {};
    const res = await fetch(`${bridgeUrl}/session/${encodeURIComponent(folderName)}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-Client-ID': sseClientId },
      body: JSON.stringify(body),
    });
    if (!res.ok) console.error('[bb] POST /session failed:', res.status);
  } catch (err) {
    console.error('[bb] POST /session error:', err);
  }
}

async function ssePostPrompt(folderName, text) {
  try {
    const res = await fetch(`${bridgeUrl}/prompt/${encodeURIComponent(folderName)}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-Client-ID': sseClientId },
      body: JSON.stringify({ text }),
    });
    if (!res.ok) {
      console.error('[bb] POST /prompt failed:', res.status);
      return { ok: false };
    }
    const data = await res.json();
    return { ok: true, queued: !!data.queued, delivered: !!data.delivered };
  } catch (err) {
    console.error('[bb] POST /prompt error:', err);
    return { ok: false };
  }
}

async function ssePostAbort(folderName) {
  try {
    await fetch(`${bridgeUrl}/abort/${encodeURIComponent(folderName)}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-Client-ID': sseClientId },
    });
  } catch (err) {
    console.error('[bb] POST /abort error:', err);
  }
}

async function ssePostExit(folderName) {
  try {
    await fetch(`${bridgeUrl}/exit/${encodeURIComponent(folderName)}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-Client-ID': sseClientId },
    });
  } catch (err) {
    console.error('[bb] POST /exit error:', err);
  }
}

async function exitSession() {
  if (!bridgeUrl || !sseCurrentFolder) return;
  await ssePostExit(sseCurrentFolder);
  sseCurrentFolder = null;
  liveState.session = {};
  liveState.messages = [];
  liveState.status = 'idle';
  liveState._activity = null;
  liveState.slashCommands = null;
  location.hash = '';
  switcherOpen = true;
  fetch(bridgeUrl + '/folders')
    .then(r => r.json())
    .then(d => { if (d.folders) handleSSEFolders(d.folders); })
    .catch(() => {});
  sseRender();
}

// === AskUserQuestion overlay ===

function showAskUserOverlay(questions, toolCallId) {
  const backdrop = document.getElementById('askBackdrop');
  const sheet = document.getElementById('askSheet');
  const content = document.getElementById('askContent');

  // Build overlay content
  let html = '';
  const isSingleImmediate = questions.length === 1 && !questions[0].multiSelect;

  questions.forEach((q, qi) => {
    html += `<div class="ask-header">${esc(q.header)}</div>`;
    html += `<div class="ask-question">${esc(q.question)}</div>`;
    html += `<div class="ask-options" data-qi="${qi}" data-multi="${q.multiSelect}">`;
    q.options.forEach((opt, oi) => {
      html += `<div class="ask-option" data-qi="${qi}" data-oi="${oi}" data-label="${esc(opt.label)}">`;
      if (q.multiSelect) {
        html += `<span class="ask-option-check">&#x2713;</span>`;
      }
      html += `<div>`;
      html += `<div class="ask-option-label">${esc(opt.label)}</div>`;
      if (opt.description) {
        html += `<div class="ask-option-desc">${esc(opt.description)}</div>`;
      }
      html += `</div></div>`;
    });
    html += `</div>`;
  });

  if (!isSingleImmediate) {
    html += `<button class="ask-confirm" id="askConfirm" data-visible="true">Send answers</button>`;
  }
  html += `<div class="ask-custom" id="askCustom">Type a custom answer instead</div>`;

  content.innerHTML = html;

  // Show overlay
  backdrop.dataset.open = 'true';
  sheet.dataset.open = 'true';

  // Option tap handlers
  content.querySelectorAll('.ask-option').forEach(opt => {
    opt.addEventListener('click', () => {
      const qi = opt.dataset.qi;
      const container = opt.closest('.ask-options');
      const isMulti = container.dataset.multi === 'true';

      if (isMulti) {
        // Toggle selection
        opt.dataset.selected = opt.dataset.selected === 'true' ? 'false' : 'true';
      } else {
        // Single-select: deselect siblings, select this one
        container.querySelectorAll('.ask-option').forEach(s => s.dataset.selected = 'false');
        opt.dataset.selected = 'true';

        // Single question + single select = immediate send
        if (isSingleImmediate) {
          sendAskUserAnswer(questions, toolCallId);
        }
      }
    });
  });

  // Confirm button (multi-select or multi-question)
  const confirmBtn = document.getElementById('askConfirm');
  if (confirmBtn) {
    confirmBtn.addEventListener('click', () => {
      sendAskUserAnswer(questions, toolCallId);
    });
  }

  // Custom answer â€” dismiss overlay, focus input
  document.getElementById('askCustom').addEventListener('click', () => {
    hideAskUserOverlay();
    document.querySelector('.input-field').focus();
  });

  // Backdrop tap dismisses
  backdrop.addEventListener('click', () => {
    hideAskUserOverlay();
    document.querySelector('.input-field').focus();
  });
}

function sendAskUserAnswer(questions, toolCallId) {
  // Collect selections
  const content = document.getElementById('askContent');
  let answer = '';

  if (questions.length === 1) {
    const selected = content.querySelectorAll('.ask-option[data-selected="true"]');
    const labels = Array.from(selected).map(s => s.dataset.label);
    answer = labels.join(', ');
  } else {
    // Multi-question: "Header: label1, label2\nHeader2: label3"
    const parts = [];
    questions.forEach((q, qi) => {
      const selected = content.querySelectorAll(`.ask-option[data-qi="${qi}"][data-selected="true"]`);
      const labels = Array.from(selected).map(s => s.dataset.label);
      if (labels.length > 0) {
        parts.push(`${q.header}: ${labels.join(', ')}`);
      }
    });
    answer = parts.join('\n');
  }

  if (answer && sseCurrentFolder) {
    ssePostPrompt(sseCurrentFolder, answer);
    // Show the answer as a user message
    liveState.messages.push({ role: 'user', content: answer });
    sseRender();
  }

  hideAskUserOverlay();
}

function hideAskUserOverlay() {
  document.getElementById('askBackdrop').dataset.open = 'false';
  document.getElementById('askSheet').dataset.open = 'false';
}

function sseConnectFolder(folder, sessionId) {
  const name = folder.name || folder;
  // Allow reconnect to same folder if switching sessions
  if (sseCurrentFolder === name && !sessionId) return;
  sseCurrentFolder = name;
  liveState.session = { project: name };
  liveState.messages = [];
  liveState.status = 'idle';
  liveState._activity = null;
  location.hash = name;
  ssePostSession(name, sessionId);
  sseRender();
}

let sseRenderQueued = false;
function updatePlaceholder() {
  const ta = document.querySelector('.input-field');
  if (!sseCurrentFolder) {
    ta.placeholder = 'Choose a folderâ€¦';
  } else if (liveState.connection === 'disconnected') {
    ta.placeholder = 'Reconnectingâ€¦';
  } else if (liveState.status === 'working') {
    const activity = liveState._activity;
    ta.placeholder = activity === 'writing' ? 'Claude is writingâ€¦' :
                     activity === 'tool' ? 'Claude is editingâ€¦' :
                     'Claude is thinkingâ€¦';
  } else {
    const model = liveState.session?.model;
    const short = model ? model.replace('claude-', '').replace(/-\d{8}$/, '') : '';
    ta.placeholder = short ? `Message ${short}â€¦` : 'Message Claudeâ€¦';
  }
}

function sseRender() {
  if (sseRenderQueued) return;
  sseRenderQueued = true;
  requestAnimationFrame(() => {
    sseRenderQueued = false;
    cachedState = liveState;
    renderStatusBar(liveState);
    renderMessages(liveState.messages);
    renderSwitcher(liveState);
    // Show action buttons when any folder is connected (local commands always available)
    const hasFolder = !!sseCurrentFolder;
    document.getElementById('slashBtn').classList.toggle('visible', hasFolder);
    document.getElementById('fileBtn').classList.toggle('visible', hasFolder);
    updatePlaceholder();
  });
}

// Start SSE if configured
function initSSE() {
  sseConnect();
  window.addEventListener('hashchange', () => {
    const folder = location.hash.slice(1);
    if (folder && folder !== sseCurrentFolder) {
      sseConnectFolder({ name: folder });
    }
  });
}

if (bridgeUrl) {
  initSSE();
} else {
  // Auto-discover: probe same-origin /folders (when served by the bridge itself).
  fetch('/folders').then((res) => {
    if (res.ok) {
      bridgeUrl = location.origin;
      initSSE();
    }
  }).catch(() => {});
}

// === Rendering helpers ===

function esc(s) {
  const d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}

// Inline markdown: code spans, bold, italic, strikethrough, links.
// Escaped first (esc), so safe for innerHTML on user input too.
function inline(s) {
  s = esc(s);
  s = s.replace(/`([^`]+)`/g, '<code>$1</code>');
  s = s.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  s = s.replace(/~~(.+?)~~/g, '<del>$1</del>');
  s = s.replace(/(?<!\*)\*(?!\*)(.+?)(?<!\*)\*(?!\*)/g, '<em>$1</em>');
  s = s.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');
  // Bare URLs â€” only those not already inside an href="..." or <a> tag
  s = s.replace(/(?<!href="|">)(https?:\/\/[^\s<)]+)/g, '<a href="$1" target="_blank" rel="noopener">$1</a>');
  return s;
}

// Minimal block-level markdown renderer for Claude's output patterns
function md(text) {
  if (!text) return '';

  const lines = text.split('\n');
  let out = '';
  let i = 0;

  while (i < lines.length) {
    const line = lines[i];

    // Blank line â€” skip
    if (line.trim() === '') { i++; continue; }

    // Headers: # through ######
    const headerMatch = line.match(/^(#{1,6})\s+(.+)$/);
    if (headerMatch) {
      const level = headerMatch[1].length;
      out += `<h${level}>${inline(headerMatch[2])}</h${level}>`;
      i++;
      continue;
    }

    // Fenced code block
    if (line.startsWith('```')) {
      i++; // skip opening fence
      let code = '';
      while (i < lines.length && !lines[i].startsWith('```')) {
        if (code) code += '\n';
        code += lines[i];
        i++;
      }
      if (i < lines.length) i++; // skip closing fence
      out += `<pre><code>${esc(code)}</code></pre>`;
      continue;
    }

    // Table: starts with |
    if (line.startsWith('|')) {
      // Collect all | lines
      const tableLines = [];
      while (i < lines.length && lines[i].startsWith('|')) {
        tableLines.push(lines[i]);
        i++;
      }
      if (tableLines.length >= 3) {
        const headers = tableLines[0].split('|').map(h => h.trim()).filter(Boolean);
        // skip separator row (index 1)
        const bodyRows = tableLines.slice(2);
        out += '<table><thead><tr>' +
          headers.map(h => `<th>${inline(h)}</th>`).join('') +
          '</tr></thead><tbody>';
        for (const r of bodyRows) {
          const cells = r.split('|').map(c => c.trim()).filter(Boolean);
          out += '<tr>' + cells.map(c => `<td>${inline(c)}</td>`).join('') + '</tr>';
        }
        out += '</tbody></table>';
      }
      continue;
    }

    // Task list: - [x] or - [ ]
    if (/^[-â€¢*]\s+\[[ xX]\]\s/.test(line)) {
      out += '<ul class="task-list">';
      while (i < lines.length && /^[-â€¢*]\s+\[[ xX]\]\s/.test(lines[i])) {
        const checked = /^[-â€¢*]\s+\[[xX]\]/.test(lines[i]);
        const text = lines[i].replace(/^[-â€¢*]\s+\[[ xX]\]\s*/, '');
        out += `<li><input type="checkbox" class="task-checkbox" disabled ${checked ? 'checked' : ''}>${inline(text)}</li>`;
        i++;
      }
      out += '</ul>';
      continue;
    }

    // Unordered list item (-, â€¢, or *) â€” spans blank lines between items
    if (/^[-â€¢*]\s/.test(line)) {
      out += '<ul>';
      while (i < lines.length) {
        if (/^[-â€¢*]\s/.test(lines[i])) {
          out += `<li>${inline(lines[i].replace(/^[-â€¢*]\s/, ''))}</li>`;
          i++;
        } else if (lines[i].trim() === '' && i + 1 < lines.length && /^[-â€¢*]\s/.test(lines[i + 1])) {
          i++; // skip blank line between list items
        } else {
          break;
        }
      }
      out += '</ul>';
      continue;
    }

    // Ordered list item â€” spans blank lines between consecutive items
    if (/^\d+\. /.test(line)) {
      out += '<ol>';
      while (i < lines.length) {
        if (/^\d+\. /.test(lines[i])) {
          out += `<li>${inline(lines[i].replace(/^\d+\. /, ''))}</li>`;
          i++;
        } else if (lines[i].trim() === '' && i + 1 < lines.length && /^\d+\. /.test(lines[i + 1])) {
          i++; // skip blank line between list items
        } else {
          break;
        }
      }
      out += '</ol>';
      continue;
    }

    // Paragraph â€” collect consecutive non-special lines
    let para = '';
    while (i < lines.length && lines[i].trim() !== '' &&
           !lines[i].startsWith('|') &&
           !/^[-â€¢*]\s/.test(lines[i]) &&
           !/^\d+\. /.test(lines[i]) &&
           !/^#{1,6}\s/.test(lines[i]) &&
           !lines[i].startsWith('```')) {
      if (para) para += ' ';
      para += lines[i];
      i++;
    }
    if (para) out += `<p>${inline(para)}</p>`;
  }

  return out;
}

// === Output trimming for small screens ===
// Transform pipeline: applied at block boundaries before rendering

function trimText(text) {
  if (!text) return text;
  // Strip <local-command-stdout> tags and trim /context output
  const stdoutRe = /<local-command-stdout>([\s\S]*?)<\/local-command-stdout>/g;
  text = text.replace(stdoutRe, (_, inner) => {
    // /context output: extract just the usage/cost summary lines
    if (inner.includes('Context:') || inner.includes('context window')) {
      const lines = inner.split('\n');
      const usageLines = lines.filter(l =>
        /^\s*Context:\s*\d/.test(l) || /token/i.test(l) || /^\s*Cost:/i.test(l) || /^\s*\d+%/.test(l)
      );
      return usageLines.length ? usageLines.join('\n').trim() : inner.trim();
    }
    return inner.trim();
  });
  return text;
}

function trimToolOutput(output, maxLines) {
  if (!output) return output;
  maxLines = maxLines || 30;
  const lines = output.split('\n');
  if (lines.length <= maxLines) return output;
  const headCount = Math.ceil(maxLines / 2);
  const tailCount = Math.floor(maxLines / 2);
  const hidden = lines.length - headCount - tailCount;
  return lines.slice(0, headCount).join('\n')
    + `\nâ€¦ ${hidden} lines hidden â€¦\n`
    + lines.slice(-tailCount).join('\n');
}

function renderLocalCommand(content) {
  // Extract inner content from <local-command-stdout> tags
  const match = content.match(/<local-command-stdout>([\s\S]*?)<\/local-command-stdout>/);
  const inner = match ? match[1].trim() : content;

  // Extract a one-line summary for the collapsed header
  // /context: "Model: claude-opus-4-6  Tokens: 73.3k / 200k (37%)"
  // /cost: the whole thing is short enough
  // /compact: "Compacted"
  let summary = '';
  const lines = inner.split('\n');
  // Look for the Tokens line (most useful for /context)
  const tokensLine = lines.find(l => /\*\*Tokens:\*\*/.test(l));
  if (tokensLine) {
    // Strip markdown bold markers
    summary = tokensLine.replace(/\*\*/g, '').trim();
  } else if (inner.length < 100) {
    // Short output like /compact or /cost â€” use as-is
    summary = inner.replace(/\n/g, ' ').trim();
  } else {
    // Fallback: first non-empty, non-heading line
    summary = lines.find(l => l.trim() && !l.startsWith('#')) || lines[0] || 'Command output';
    summary = summary.replace(/\*\*/g, '').trim();
  }

  const block = document.createElement('div');
  block.className = 'local-cmd';
  block.dataset.expanded = 'false';

  block.innerHTML = `
    <div class="local-cmd-header">
      <span class="tool-chevron">&#x25B8;</span>
      <span class="local-cmd-summary">${esc(summary)}</span>
    </div>
    <div class="local-cmd-body">${md(inner)}</div>
  `;

  block.querySelector('.local-cmd-header').addEventListener('click', () => {
    block.dataset.expanded = block.dataset.expanded === 'true' ? 'false' : 'true';
  });

  return block;
}

const THINKING_TRUNCATE = 500;

function truncateThinking(text) {
  if (text.length <= THINKING_TRUNCATE) return text;
  return text.slice(0, THINKING_TRUNCATE) + 'â€¦';
}

function renderThinkingChip(thinkingText) {
  const chip = document.createElement('div');
  chip.className = 'chip thinking-done';
  const truncated = truncateThinking(thinkingText);
  const needsMore = thinkingText.length > THINKING_TRUNCATE;

  chip.innerHTML =
    `<span class="c-status done" style="color:var(--accent)">&#x2726;</span>` +
    `<span class="c-name" style="color:var(--accent)">Thought</span>` +
    `<div class="c-detail">${esc(truncated)}` +
    (needsMore ? `<span class="thinking-more" style="color:var(--accent);cursor:pointer;display:block;margin-top:4px;font-size:0.55rem">Show full thinking</span>` : '') +
    `</div>`;

  chip.addEventListener('click', (e) => {
    if (e.target.classList.contains('thinking-more')) {
      // Replace truncated with full text
      const detail = chip.querySelector('.c-detail');
      detail.textContent = thinkingText;
      return;
    }
    chip.classList.toggle('expanded');
  });

  return chip;
}

function renderChip(tc) {
  const statusClass = tc.status === 'completed' ? 'done' : tc.status === 'running' ? 'run' : 'err';
  const statusIcon = tc.status === 'completed' ? '&#x2713;' :
                     tc.status === 'running' ? '&#x25cf;' : '&#x2717;';
  const chipClass = 'chip' + (tc.status === 'error' ? ' error' : '') + (tc.status === 'running' ? ' running' : '');

  const chip = document.createElement('div');
  chip.className = chipClass;
  chip.dataset.toolId = tc.name + '|' + (tc.input || '');

  const detail = tc.input + (tc.output ? '\n' + trimToolOutput(tc.output) : '');

  chip.innerHTML =
    `<span class="c-status ${statusClass}">${statusIcon}</span>` +
    `<span class="c-name">${esc(tc.name)}</span>` +
    (tc.input ? `<span class="c-path">${esc(tc.input)}</span>` : '') +
    `<div class="c-detail">${esc(detail)}</div>`;

  chip.addEventListener('click', () => {
    chip.classList.toggle('expanded');
  });

  return chip;
}

function renderMessages(messages) {
  const el = document.getElementById('messages');

  // Snapshot expanded chips before rebuild
  const expandedChips = new Set();
  for (const chip of el.querySelectorAll('.chip.expanded')) {
    if (chip.dataset.toolId) expandedChips.add(chip.dataset.toolId);
  }
  const thinkingExpanded = !!el.querySelector('.chip.thinking-done.expanded, .chip.thinking.expanded');

  el.innerHTML = '';

  for (const msg of messages) {
    // Thinking chip â€” before content (thinking happened first, keeps visual position)
    const hasThinking = msg.thinking && msg.role === 'assistant';
    if (hasThinking) {
      const grid = document.createElement('div');
      grid.className = 'chip-grid';
      const chip = renderThinkingChip(msg.thinking);
      if (thinkingExpanded) chip.classList.add('expanded');
      grid.appendChild(chip);
      el.appendChild(grid);
    }

    // Text content
    if (msg.content !== null && msg.content !== undefined) {
      // Local command output â€” render as collapsible block
      if (msg.role === 'assistant' && msg.content.includes('<local-command-stdout>')) {
        el.appendChild(renderLocalCommand(msg.content));
      } else {
        const div = document.createElement('div');
        if (msg.role === 'user' && msg.synthetic) {
          div.className = 'msg-system';
          div.textContent = msg.content;
        } else if (msg.role === 'user') {
          div.className = 'msg-user';
          div.innerHTML = inline(msg.content);
          if (msg._msgId) div.dataset.msgId = msg._msgId;
          if (msg.pending) div.dataset.pending = 'true';
          else if (msg.queued) div.dataset.queued = 'true';
        } else {
          div.className = 'msg-assistant';
          div.innerHTML = md(trimText(msg.content));
        }
        el.appendChild(div);
      }
    }

    // Tool calls â€” render as chip grid (after content)
    const hasTools = msg.tool_calls && msg.tool_calls.length;
    if (hasTools) {
      const grid = document.createElement('div');
      grid.className = 'chip-grid';
      for (const tc of msg.tool_calls) {
        const chip = renderChip(tc);
        if (expandedChips.has(chip.dataset.toolId)) chip.classList.add('expanded');
        grid.appendChild(chip);
      }
      el.appendChild(grid);
    }
  }

  // Activity chip â€” pulsing indicator at the end when Claude is working
  if (liveState.status === 'working' && liveState.connection !== 'disconnected') {
    const activity = liveState._activity || 'thinking';
    // Only show thinking/writing chips â€” tool activity is shown by the running chip itself
    if (activity === 'thinking' || activity === 'writing') {
      const label = activity === 'thinking' ? 'Thinkingâ€¦' : 'Writingâ€¦';
      const chip = document.createElement('div');
      chip.className = 'chip ' + activity;

      // During thinking, show accumulated text in expandable detail
      const lastMsg = liveState.messages[liveState.messages.length - 1];
      const thinkingText = activity === 'thinking' && lastMsg?.thinking ? lastMsg.thinking : null;
      if (thinkingText) {
        chip.innerHTML = `<span class="c-name">${label}</span>` +
          `<div class="c-detail">${esc(truncateThinking(thinkingText))}</div>`;
        if (thinkingExpanded) chip.classList.add('expanded');
        chip.addEventListener('click', () => chip.classList.toggle('expanded'));
      } else {
        chip.innerHTML = `<span class="c-name">${label}</span>`;
      }

      // Append to last chip-grid if one exists, otherwise create new grid
      const lastGrid = el.querySelector('.chip-grid:last-child');
      if (lastGrid && lastGrid === el.lastElementChild) {
        lastGrid.appendChild(chip);
      } else {
        const grid = document.createElement('div');
        grid.className = 'chip-grid';
        grid.appendChild(chip);
        el.appendChild(grid);
      }
    }
  }

  // Only auto-scroll if user hasn't scrolled up to read earlier content
  if (!userScrolledUp) {
    el.scrollTop = el.scrollHeight;
  }
}

// Track user scroll intent on the messages container
document.getElementById('messages').addEventListener('scroll', () => {
  const el = document.getElementById('messages');
  // "At bottom" = within 60px of the end (threshold for finger imprecision)
  const atBottom = el.scrollTop + el.clientHeight >= el.scrollHeight - 60;
  userScrolledUp = !atBottom;
});

function renderStatusBar(state) {
  const sess = state.session || {};
  document.getElementById('project').textContent = sess.project || '';

  const ctxEl = document.getElementById('contextPct');
  const ctxBtn = document.getElementById('contextBtn');
  const pct = sess.context_pct;
  if (pct !== undefined && pct !== null) {
    ctxEl.textContent = pct + '%';
    ctxBtn.dataset.level = pct >= 85 ? 'critical' : pct >= 70 ? 'low' : '';
  } else if (sess.project) {
    ctxEl.textContent = '0%';
    ctxBtn.dataset.level = '';
  } else {
    ctxEl.textContent = '';
    ctxBtn.dataset.level = '';
  }

  // Connection state
  const connected = state.connection !== 'disconnected';
  document.body.dataset.connection = connected ? 'connected' : 'disconnected';
  document.getElementById('switcherConnectionDot').dataset.state = connected ? 'connected' : 'disconnected';

  // Busy state â€” used by send button and activity chips
  const busy = connected && state.status === 'working';
  document.body.dataset.busy = busy;

  // Error toast â€” auto-dismiss after 5s
  const toast = document.getElementById('errorToast');
  if (state.error) {
    toast.textContent = state.error;
    toast.classList.add('visible');
    clearTimeout(toast._dismissTimer);
    toast._dismissTimer = setTimeout(() => {
      toast.classList.remove('visible');
      liveState.error = null;
    }, 5000);
  } else {
    toast.classList.remove('visible');
  }

  updateSendButton();
}

function renderSwitcher(state) {
  const switcher = document.getElementById('switcher');
  const list = document.getElementById('switcherList');

  const backdrop = document.getElementById('switcherBackdrop');
  if (!state.switcher || !switcherOpen) {
    switcher.dataset.open = 'false';
    backdrop.dataset.open = 'false';
    return;
  }

  backdrop.dataset.open = 'true';
  switcher.dataset.open = 'true';
  list.innerHTML = '';

  const currentId = state.session ? state.session.id : null;
  const sessions = state.switcher.sessions || [];
  const filter = document.getElementById('switcherSearch').value.trim().toLowerCase();

  // Group: current/ended first, then active, dormant, old
  const groups = { active: [], dormant: [], old: [] };
  let top = null; // current session or most recently ended

  for (const s of sessions) {
    if (filter && !s.project.toLowerCase().includes(filter)) continue;
    if (s.project === sseCurrentFolder) { top = s; continue; }
    if (s.status === 'ended' && !top) { top = s; continue; }
    if (groups[s.status]) groups[s.status].push(s);
    else groups.old.push(s);
  }

  function timeAgo(iso) {
    if (!iso) return '';
    const mins = Math.floor((Date.now() - new Date(iso)) / 60000);
    if (mins < 0 || mins > 525600) return ''; // negative or >1 year = bad data
    if (mins < 1) return 'now';
    if (mins < 60) return mins + 'm';
    const hrs = Math.floor(mins / 60);
    if (hrs < 24) return hrs + 'h';
    return Math.floor(hrs / 24) + 'd';
  }

  function shortModel(model) {
    if (!model) return '';
    return model.replace('claude-', '').replace(/-\d+$/, '');
  }

  function makeItem(s, isCurrent) {
    const pct = s.context_pct;
    const level = pct >= 85 ? 'critical' : pct >= 70 ? 'low' : '';
    const hasSessions = s.sessions && s.sessions.length > 1;
    const isExpanded = switcherExpandedFolder === s.project;
    const item = document.createElement('div');
    item.className = 'switcher-item';
    item.dataset.status = s.status;
    if (isCurrent) item.dataset.current = 'true';

    // Main row: body (clickable â†’ connect) + chevron (clickable â†’ expand)
    const row = document.createElement('div');
    row.className = 'switcher-item-row';

    const body = document.createElement('div');
    body.className = 'switcher-item-body';
    body.innerHTML = `
      <span class="switcher-dot" data-status="${s.status}"></span>
      <div class="switcher-info">
        <div class="switcher-project">${esc(s.project)}</div>
        <div class="switcher-last-msg">${esc(s.last_message || '')}</div>
      </div>
      <div class="switcher-meta">
        <div class="switcher-context" data-level="${level}">${pct ? pct + '%' : ''}</div>
        <div class="switcher-time">${timeAgo(s.updated)}</div>
      </div>
    `;
    body.addEventListener('click', () => {
      if (bridgeUrl) {
        sseConnectFolder({ name: s.project, path: s.id });
        closeSwitcher();
      }
    });
    row.appendChild(body);

    if (hasSessions) {
      const humanCount = s.sessions.filter(sess => sess.humanInteraction !== false).length;
      const countBadge = document.createElement('span');
      countBadge.className = 'switcher-session-count';
      countBadge.textContent = humanCount;
      row.appendChild(countBadge);

      const chevron = document.createElement('div');
      chevron.className = 'switcher-chevron';
      chevron.dataset.expanded = isExpanded ? 'true' : 'false';
      chevron.textContent = '\u203A'; // â€º
      chevron.addEventListener('click', (e) => {
        e.stopPropagation();
        switcherExpandedFolder = isExpanded ? null : s.project;
        renderSwitcher(state);
      });
      row.appendChild(chevron);
    }

    item.appendChild(row);

    // Expanded session list
    if (hasSessions && isExpanded) {
      const sessionsDiv = document.createElement('div');
      sessionsDiv.className = 'switcher-sessions';

      // Filter to human-interactive sessions only (hide subagent spam)
      const humanSessions = s.sessions.filter(sess => sess.humanInteraction !== false);
      const hiddenCount = s.sessions.length - humanSessions.length;

      for (const sess of humanSessions) {
        const sessionPct = sess.contextPct;
        const sessionLevel = sessionPct >= 85 ? 'critical' : sessionPct >= 70 ? 'low' : '';
        const sessionRow = document.createElement('div');
        sessionRow.className = 'switcher-session-row';
        sessionRow.innerHTML = `
          <span class="switcher-dot" data-status="${sess.closed ? 'ended' : 'dormant'}"></span>
          <span class="switcher-session-id">${esc(sess.id.slice(0, 8))}</span>
          <span class="switcher-session-model">${esc(shortModel(sess.model))}</span>
          <span class="switcher-context" data-level="${sessionLevel}">${sessionPct ? sessionPct + '%' : ''}</span>
          <span class="switcher-time">${timeAgo(sess.lastActive)}</span>
        `;
        sessionRow.addEventListener('click', (e) => {
          e.stopPropagation();
          sseConnectFolder({ name: s.project, path: s.id }, sess.id);
          closeSwitcher();
        });
        sessionsDiv.appendChild(sessionRow);
      }

      // New Session button
      const newRow = document.createElement('div');
      newRow.className = 'switcher-new-session';
      newRow.innerHTML = '+ New Session';
      newRow.addEventListener('click', (e) => {
        e.stopPropagation();
        sseConnectFolder({ name: s.project, path: s.id }, 'new');
        closeSwitcher();
      });
      sessionsDiv.appendChild(newRow);

      if (hiddenCount > 0) {
        const hidden = document.createElement('div');
        hidden.style.cssText = 'font-size: 0.65rem; color: var(--text-dim); padding: 4px 10px;';
        hidden.textContent = `${hiddenCount} subagent session${hiddenCount > 1 ? 's' : ''} hidden`;
        sessionsDiv.appendChild(hidden);
      }

      item.appendChild(sessionsDiv);
    }

    return item;
  }

  if (top) list.appendChild(makeItem(top, true));

  if (groups.active.length) {
    const label = document.createElement('div');
    label.className = 'switcher-section';
    label.textContent = 'Active';
    list.appendChild(label);
    for (const s of groups.active) list.appendChild(makeItem(s, false));
  }

  if (groups.dormant.length) {
    const label = document.createElement('div');
    label.className = 'switcher-section';
    label.textContent = 'Dormant';
    list.appendChild(label);
    for (const s of groups.dormant) list.appendChild(makeItem(s, false));
  }

  if (groups.old.length) {
    const label = document.createElement('div');
    label.className = 'switcher-section';
    label.textContent = 'Recent';
    list.appendChild(label);
    for (const s of groups.old) list.appendChild(makeItem(s, false));
  }
}

// Bridge mode renders via its own event handlers â€” no render() call needed.

function closeSwitcher() {
  switcherOpen = false;
  document.getElementById('switcher').dataset.open = 'false';
  document.getElementById('switcherBackdrop').dataset.open = 'false';
  document.getElementById('switcherSearch').value = '';
}

// Switcher: open/close uses client-side state, search re-filters without refetching
document.getElementById('switcherClose').addEventListener('click', closeSwitcher);
document.getElementById('switcherBackdrop').addEventListener('click', closeSwitcher);

// Swipe-down-to-dismiss on switcher
{
  const switcherEl = document.getElementById('switcher');
  let swipeStartY = null;
  let swipeStartTranslate = 0;
  const handleEl = switcherEl.querySelector('.switcher-handle');

  handleEl.addEventListener('touchstart', (e) => {
    swipeStartY = e.touches[0].clientY;
    swipeStartTranslate = 0;
    switcherEl.style.transition = 'none';
  }, { passive: true });

  handleEl.addEventListener('touchmove', (e) => {
    if (swipeStartY === null) return;
    const dy = e.touches[0].clientY - swipeStartY;
    if (dy > 0) {
      swipeStartTranslate = dy;
      switcherEl.style.transform = `translateY(${dy}px)`;
    }
  }, { passive: true });

  handleEl.addEventListener('touchend', () => {
    switcherEl.style.transition = '';
    if (swipeStartTranslate > 80) {
      closeSwitcher();
    } else {
      switcherEl.style.transform = '';
    }
    swipeStartY = null;
  });

  // Tap empty space below list items dismisses (the switcher itself, not just backdrop)
  document.getElementById('switcherList').addEventListener('click', (e) => {
    if (e.target === e.currentTarget) closeSwitcher();
  });
}

document.getElementById('switcherSearch').addEventListener('input', () => {
  if (cachedState) renderSwitcher(cachedState);
});

// Folder lozenge: tap opens session switcher
document.getElementById('folderBtn').addEventListener('click', () => {
  switcherOpen = true;
  switcherExpandedFolder = null;
  if (bridgeUrl) {
    fetch(bridgeUrl + '/folders')
      .then(r => r.json())
      .then(d => { if (d.folders) handleSSEFolders(d.folders); })
      .catch(() => {});
  }
  if (cachedState) renderSwitcher(cachedState);
});

// Context lozenge: tap when amber/red offers exit, long-press always offers exit
{
  const contextBtn = document.getElementById('contextBtn');
  let longPressTimer = null;
  let didLongPress = false;
  contextBtn.addEventListener('pointerdown', () => {
    didLongPress = false;
    longPressTimer = setTimeout(() => {
      didLongPress = true;
      if (sseCurrentFolder && confirm('End this session and return to the lobby?')) {
        exitSession();
      }
    }, 800);
  });
  contextBtn.addEventListener('pointerup', () => {
    clearTimeout(longPressTimer);
    if (didLongPress) return;
    const level = contextBtn.dataset.level;
    if ((level === 'low' || level === 'critical') && sseCurrentFolder) {
      if (confirm('Context is running high. End this session and start fresh?')) {
        exitSession();
      }
    }
  });
  contextBtn.addEventListener('pointercancel', () => clearTimeout(longPressTimer));
}

// Auto-grow textarea: grows upward because flex layout shrinks messages area
const ta = document.querySelector('.input-field');
const msgEl = document.getElementById('messages');
const sendBtn = document.getElementById('sendBtn');

ta.addEventListener('input', () => {
  ta.style.height = 'auto';
  ta.style.height = Math.min(ta.scrollHeight, 120) + 'px';
  updateSendButton();
});

// Tapping input resets scroll â€” user wants to see latest to compose a reply
ta.addEventListener('focus', () => {
  userScrolledUp = false;
  msgEl.scrollTop = msgEl.scrollHeight;
});

// Enter = newline. Shift+Enter or Cmd/Ctrl+Enter = submit.
ta.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && (e.shiftKey || e.metaKey || e.ctrlKey)) {
    e.preventDefault();
    sendBtn.click();
  }
});

// Update send button state based on current text and connection/busy state
function updateSendButton() {
  const hasText = ta.value.trim().length > 0;
  const isDisconnected = document.body.dataset.connection === 'disconnected';
  const isBusy = document.body.dataset.busy === 'true';

  const isLive = !!bridgeUrl;
  if (isDisconnected && !isLive) {
    // File mode disconnected â€” disable send
    sendBtn.dataset.stop = 'false';
    sendBtn.dataset.active = 'false';
    sendBtn.innerHTML = '&#x2191;';
  } else if (isDisconnected && isLive) {
    // Live mode disconnected â€” allow send (queues as pending in WS, disabled in SSE)
    sendBtn.dataset.stop = 'false';
    sendBtn.dataset.active = hasText ? 'true' : 'false';
    sendBtn.innerHTML = '&#x2191;';
  } else if (isBusy && !hasText) {
    sendBtn.dataset.stop = 'true';
    delete sendBtn.dataset.active;
    sendBtn.innerHTML = '&#x25A0;'; // stop
  } else {
    sendBtn.dataset.stop = 'false';
    sendBtn.dataset.active = hasText ? 'true' : 'false';
    sendBtn.innerHTML = '&#x2191;'; // send
  }
}

// Undo state â€” tracks the last sent message so it can be recalled
let undoTimer = null;
let undoEl = null;

function clearUndo() {
  if (undoTimer) clearTimeout(undoTimer);
  if (undoEl) {
    undoEl.dataset.fading = 'true';
    setTimeout(() => undoEl?.remove(), 300);
  }
  undoTimer = null;
  undoEl = null;
}

// Send button tap
sendBtn.addEventListener('click', () => {
  // Request notification permission on first user gesture
  if (!pushPermissionGranted && 'Notification' in window && Notification.permission === 'default') {
    pushRequestPermission();
  }

  const isDisconnected = document.body.dataset.connection === 'disconnected';
  const isLive = !!bridgeUrl;
  if (isDisconnected && !isLive) return;

  const isBusy = document.body.dataset.busy === 'true';
  const hasText = ta.value.trim().length > 0;

  if (isBusy && !hasText) {
    // Stop â€” abort Claude's current turn
    if (bridgeUrl && sseCurrentFolder) {
      ssePostAbort(sseCurrentFolder);
    }
  } else if (hasText) {
    // Clear any previous undo
    clearUndo();

    const text = ta.value.trim();
    const msgId = 'msg-' + Date.now() + '-' + Math.random().toString(36).slice(2, 6);

    // Add message to DOM immediately as pending
    const bubble = document.createElement('div');
    bubble.className = 'msg-user';
    bubble.innerHTML = inline(text);
    bubble.dataset.msgId = msgId;
    bubble.dataset.pending = 'true';
    msgEl.appendChild(bubble);

    // Also add to liveState so re-renders preserve it
    if (bridgeUrl) {
      liveState.messages.push({
        role: 'user', content: text, _msgId: msgId,
        pending: true, queued: false,
      });
    }

    // Send via SSE bridge â€” transition pending â†’ queued/delivered on response
    if (bridgeUrl && sseCurrentFolder) {
      ssePostPrompt(sseCurrentFolder, text).then(result => {
        const msg = liveState.messages.find(m => m._msgId === msgId);
        if (!msg) return;
        msg.pending = false;
        if (result.queued) {
          msg.queued = true;
          bubble.dataset.pending = 'false';
          bubble.dataset.queued = 'true';
        } else if (result.delivered) {
          // Delivered immediately â€” remove pending styling
          msg.queued = false;
          delete bubble.dataset.pending;
          delete bubble.dataset.queued;
        }
      });
    }

    // Undo button â€” available briefly after send
    {
      const undo = document.createElement('div');
      undo.className = 'msg-undo';
      undo.dataset.msgId = msgId;
      undo.innerHTML = '<button>undo</button>';
      msgEl.appendChild(undo);
      undoEl = undo;

      undo.querySelector('button').addEventListener('click', () => {
        // Remove from liveState
        const li = liveState.messages.findIndex(m => m._msgId === msgId);
        if (li !== -1) liveState.messages.splice(li, 1);
        // Remove from DOM
        bubble.remove();
        undo.remove();
        undoEl = null;
        if (undoTimer) clearTimeout(undoTimer);
        undoTimer = null;
        ta.value = text;
        ta.style.height = 'auto';
        ta.style.height = Math.min(ta.scrollHeight, 120) + 'px';
        ta.focus();
        updateSendButton();
      });

      // No timer â€” undo stays until message is flushed
    }

    // Scroll to bottom and reset scroll tracking
    userScrolledUp = false;
    msgEl.scrollTop = msgEl.scrollHeight;

    // Clear textarea
    ta.value = '';
    ta.style.height = 'auto';
    updateSendButton();
  }
});

// --- Slash command sheet ---
const slashSheet = document.getElementById('slashSheet');
const slashList = document.getElementById('slashList');
const slashBtn = document.getElementById('slashBtn');

const LOCAL_SLASH_COMMANDS = [
  { name: 'context', description: 'Show context window usage', local: true },
  { name: 'cost', description: 'Show session cost', local: true },
  { name: 'compact', description: 'Compact conversation history', local: true },
  { name: 'abort', description: 'Kill hung Claude process', local: true },
  { name: 'exit', description: 'End session and return to lobby', local: true },
];

function openSlashSheet() {
  const cmds = liveState.slashCommands?.length ? liveState.slashCommands : LOCAL_SLASH_COMMANDS;
  if (!cmds.length) return;

  slashList.innerHTML = '';
  for (const cmd of cmds) {
    const row = document.createElement('div');
    row.className = 'slash-cmd';

    const nameEl = document.createElement('span');
    nameEl.className = 'slash-cmd-name';
    nameEl.textContent = cmd.name;
    row.appendChild(nameEl);

    if (cmd.description) {
      const descEl = document.createElement('span');
      descEl.className = 'slash-cmd-desc';
      descEl.textContent = cmd.description;
      row.appendChild(descEl);
    }
    if (cmd.local) {
      const badge = document.createElement('span');
      badge.className = 'slash-cmd-local';
      badge.textContent = 'local';
      row.appendChild(badge);
    }

    row.addEventListener('click', () => {
      slashSheet.classList.remove('open');
      // /exit is handled client-side â€” triggers exitSession with confirmation
      if (cmd.name === 'exit') {
        if (sseCurrentFolder && confirm('End this session and return to the lobby?')) {
          exitSession();
        }
        return;
      }
      // /abort kills the CC process â€” emergency escape for hung sessions
      if (cmd.name === 'abort') {
        if (sseCurrentFolder) {
          ssePostAbort(sseCurrentFolder);
        }
        return;
      }
      ta.value = '/' + cmd.name;
      ta.style.height = 'auto';
      ta.style.height = Math.min(ta.scrollHeight, 120) + 'px';
      updateSendButton();
      // Local commands auto-send â€” they're instant, no reason to pause
      if (cmd.local) {
        sendBtn.click();
      } else {
        ta.focus();
      }
    });
    slashList.appendChild(row);
  }
  slashSheet.classList.add('open');
}

slashBtn.addEventListener('click', openSlashSheet);

// Close on backdrop tap
slashSheet.addEventListener('click', (e) => {
  if (e.target === slashSheet) slashSheet.classList.remove('open');
});
</script>
</body>
</html>
